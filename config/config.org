#+TITLE: My Emacs Configuration
#+AUTHOR: John Ankarstr√∂m
#+LANGUAGE: en
#+OPTIONS: H:4 num:2 ':t todo:nil
#+PROPERTY: header-args :tangle no :results value silent
#+TODO: TODO(t) FIXME(f) | DONE(d)

#+HTML_HEAD: <link href="https://fonts.googleapis.com/css?family=Playfair+Display" rel="stylesheet" />
#+HTML_HEAD: <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" />
#+HTML_HEAD: <link rel="stylesheet" href="config.css" type="text/css" />

# Things from old config yet to be added:
# - tty-shell-command functions (incl. dynamic cursor shape for terminal)
  
* Introduction

Welcome to my Emacs configuration. It is written in the style of literate
programming, which means, in this case, that it's written in Org-mode. Perhaps
unlike other Emacs configurations written in Org, however, it is written in a
non-linear fashion. That means that source code is presented in a way that's
suitable for the /documenting/ of code, and not the running of code. If you
copied all source blocks in this document and put them in the same order in an
Emacs configuration file, it might not work.

** "Best of"

My Emacs configuration is very long. I understand if nobody will ever read
it all, but I do think there are parts of it /worth/ reading. Following is a list
of quick links to the most interesting sections of this document.

- [[#org-tree-view][org-tree-view]] :: A sidebar for conveniently browsing all the headings in an
     Org document. The resulting package is as interesting, I would say, as some
     of the underlying code.


* Packages

** Package management

First and foremost, I define what sources to install packages from:

#+NAME: c:pkg:management
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives
      '(("gnu" . "http://elpa.gnu.org/packages/")
        ("org" . "http://orgmode.org/elpa/")
        ("melpa" . "http://melpa.org/packages/")
        ("melpa-stable" . "http://stable.melpa.org/packages/")))
(setq package-archive-priorities
      '(("melpa-stable" . 1)))
(package-initialize)
#+END_SRC

I call =package-initialize= here, because I want all installed packages to be
loaded automatically with their default configuration, /except/ the ones I
explicitly configure with =use-package=.

For that I initialize /use-package/:

#+NAME: c:pkg:management
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
(require 'diminish) ; if you use :diminish
(require 'bind-key) ; if you use any :bind variant
#+END_SRC

** List of packages

As I've said, this document is presented in a non-linear way. Under this rubric,
I list all the packages that I have installed and that I use. However, their
respective configurations are listed elsewhere.

*** Packages with configuration elsewhere

- [[#multiple-cursors][multiple-cursors]]
- [[#visual-regexp][visual-regexp]]
- [[#expand-region][expand-region]]
- [[#paredit][paredit]]
- [[#iy-go-to-char][iy-go-to-char]]
- [[#avy][avy]]
- [[#origami][origami]]
- [[#helm][helm]]
- [[#projectile][projectile]]
- [[#magit][magit]]
- [[#git-gutter][git-gutter+]]
- [[#openwith][openwith]]
- [[#org-mode][org-mode]]

*** Packages without interesting configuration

In order to do their job, some packages have to be explicitly enabled in the
Emacs configuration, but do not need to be further configured. For that reason,
I probably won't mention these packages elsewhere, and instead just list them
here with a short description of why I like them.

- rainbow-delimiters :: Paints matching parentheses with the same color.

- ace-link :: Nice little extension to /avy/ that does the same thing, but for
              links in help buffers.

- nlinum :: Line numbers, but faster than =linum=. I don't use this much, but it's
            nice to have when you need it.

- popwin :: Makes popup windows /so/ much easier to work with - this is a
            must-have.

- helm-org-rifle :: Makes it /a bit/ easier to browse through Org documents - not
                    perfect though.

- buffer-move :: Lets me switch buffers between two windows - pretty handy.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp :exports none
(use-package rainbow-delimiters
  :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

(use-package ace-link
  :ensure avy
  :config
  (ace-link-setup-default))

(use-package nlinum
  :bind (("C-c l" . nlinum-mode)))

(use-package popwin
  :init
  (require 'popwin)
  (popwin-mode 1))

(use-package helm-org-rifle
  :disabled
  :bind (("C-c f" . helm-org-rifle-current-buffer)
         ("C-c F" . helm-org-rifle)))

(use-package buffer-move
  :init
  :bind (("C-c <up>"    . buf-move-up)
         ("C-c <down>"  . buf-move-down)
         ("C-c <left>"  . buf-move-left)
         ("C-c <right>" . buf-move-right)))
#+END_SRC


* Basic preferences
:PROPERTIES:
:CUSTOM_ID: basic-preferences
:END:

In my configuration, there are some basic settings that don't really belong
under any section in this documentation. Most of them are set using the
/Customize/ interface, but here are the ones that aren't:

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(server-start)         ; use emacs as a server
(electric-pair-mode 1) ; auto-insert matching pairs
(menu-bar-mode -1)     ; disable menu bar
(tool-bar-mode -1)     ; disable gui toolbar
(save-place-mode 1)    ; save cursor position
(xterm-mouse-mode t)   ; use mouse (somewhat effectively) in terminal

;; Activate auto-fill-mode for all text buffers
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

** Directories
:PROPERTIES:
:CUSTOM_ID: directories
:END:

Per default, Emacs insists on making a mess inside =~/.emacs.d=. These settings
prevent that.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(setf custom-file (concat user-emacs-directory "custom.el"))

(setf emacs-state-directory (expand-file-name "state/" user-emacs-directory))
(defun state-dir (file)
  (concat emacs-state-directory file))

;; - Various places

(setf auto-save-list-file-prefix   (state-dir "auto-save-list/.saves~")
      save-place-file              (state-dir "save-place")
      recentf-save-file            (state-dir "recentf")
      ido-save-directory-list-file (state-dir "ido.last")
      eshell-directory-name        (state-dir "eshell")
      nsm-settings-file            (state-dir "network-security.data")
      backup-directory-alist       `((".*" . ,(state-dir "saves"))))

;; - Tramp
(setf tramp-backup-directory-alist backup-directory-alist)
(setf tramp-auto-save-directory (state-dir
                                        "tramp/auto-save/"))
(setf tramp-persistency-file-name (state-dir
                                          "tramp/persistency.el"))

;; - Projectile
(setf projectile-cache-file (concat emacs-state-directory
                                    "projectile/cache.el"))
(setf projectile-known-projects-file
      (concat emacs-state-directory
              "projectile/known-projects.el"))

;; - File for activated disabled commands
(defadvice en/disable-command (around put-in-custom-file activate)
  "Put declarations in `custom-file'."
  (let ((user-init-file (concat user-emacs-directory ".commands")))
    ad-do-it))
(load-file (concat user-emacs-directory ".commands"))
#+END_SRC

** Keybindings
:PROPERTIES:
:CUSTOM_ID: keybindings
:END:

Here are a couple of keybindings that don't really fit in under any other
headline. Most of them are based on built-in functions.

#+NAME: c:keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-<f1>") #'menu-bar-mode)

(global-set-key (kbd "M-]") #'other-window)
(global-set-key (kbd "M-[") (lambda (n)
                              (interactive "p")
                              (other-window (* -1 n))))

(global-set-key (kbd "<S-home>") #'previous-buffer)
(global-set-key (kbd "<S-end>") #'next-buffer)

(global-set-key (kbd "M-n") (lambda (n) (interactive "p") (scroll-up n)))
(global-set-key (kbd "M-p") (lambda (n) (interactive "p") (scroll-down n)))
;; Use for other modes too
(define-key Info-mode-map    (kbd "M-n") (lookup-key global-map (kbd "M-n")))
(define-key Info-mode-map    (kbd "M-p") (lookup-key global-map (kbd "M-p")))
(add-hook 'message-mode-hook
	  (lambda ()
	    (define-key message-mode-map (kbd "M-n") (lookup-key global-map (kbd "M-n")))))

(global-set-key (kbd "<C-tab>") #'completion-at-point)
#+END_SRC

Apart from defining new ones, there are some keybindings that I remove. One
problematic keybinding is ~C-z~. It suspends Emacs - useful in terminals, annoying
in the graphical version of Emacs. The following code disables that keybinding
for GUI Emacs, but keeps it for =emacs -nw= and =emacsclient -t=.

#+NAME: c:keybindings
#+BEGIN_SRC emacs-lisp
(defun suspend-frame-unless-gui (oldfun &rest r)
  (unless (display-graphic-p) (apply oldfun r)))

(advice-add #'suspend-frame :around #'suspend-frame-unless-gui)
#+END_SRC

It's not strictly a keybinding, but I still felt it belonged in this section.

** Helper functions
:PROPERTIES:
:CUSTOM_ID: functions
:END:

Here is a collection of useful helper functions that I use in my Emacs
configuration.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun delete-and-extract-comment (&optional bol-arg)
  "Delete and return the comment at the end of the line. If there
is no comment, return nil."
  (let (comment)
    (save-excursion
      (move-beginning-of-line (or bol-arg 1))
      (when (skip-syntax-forward "^<" (point-at-eol))
        (setq comment (delete-and-extract-region (point) (point-at-eol)))
        (delete-horizontal-space)))
    (if (string-equal "" comment) nil comment)))

(defmacro --fcase (form &rest arg-then)
  "For each `arg-then', evaluate `form' with the car of
`arg-then' exposed as `it'. For the first `arg-then' for which
the evaluation of `form' returns true, evaluate and return then
cdr of `arg-then'.

If the car of `arg-then' is `else', its cdr will be always be
evaluated, if no `arg-then' before has resulted in a true
evaluation of `form'.

   (--fcase (string-prefix-p it my-string)
            (\"prefix-\"       (message \"Prefix: prefix-\"))
            (\"other-prefix-\" (message \"Prefix; other-else-\"))
            (prefix            (message \"No prefix\")))"
  (declare (debug (form form arg-then form)))
  `(cl-loop
      for it-then in ',arg-then
      do (let ((it   (car it-then))
               (then (cdr it-then)))
           (unless (eq it 'else) (setf it (eval it)))
           (if (or (eq it 'else) ,form)
               (cl-return
                 (car (last (mapcar
                             (lambda (exp) (eval exp))
                             then))))))))
#+END_SRC

** Session management
:PROPERTIES:
:CUSTOM_ID: session-management
:END:

If there is a way to save the current window configuration to a file, and I mean
/only/ the window configuration (and, of course, the buffers that are open in
those windows), *please tell me*.

For the moment, I use =desktop-save-mode=, but I'm unhappy. It saves far too many
irrelevant things, like the theme I'm using and all buffers. I only want to
save the currently visible buffers and the positions of their windows. That's
it.

In the meantime, this is my configuration for =desktop-save-mode=.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(setq desktop-dirname             (concat emacs-state-directory "desktop/")
      desktop-base-file-name      "emacs.desktop"
      desktop-base-lock-name      "lock"
      desktop-path                (list desktop-dirname)
      desktop-save                t)
#+END_SRC

Furthrmore, I have a custom function that lets me easily activate the mode:

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun init-desktop (&optional arg)
  "Load the desktop (if C-u is provided) and enable autosaving."

  (interactive "p")
  (if current-prefix-arg (desktop-read))
  (desktop-save-mode 1)
  (message "Desktop-Save mode enabled"))

(global-set-key (kbd "C-c D") 'init-desktop)
#+END_SRC

** Shebang mode detection

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
;; Shebang mode detection
(add-to-list 'interpreter-mode-alist
             '("python3" . python-mode))
#+END_SRC


* Text editing

** Multiple cursors
:PROPERTIES:
:CUSTOM_ID: multiple-cursors
:END:

=multiple-cursors= is another indispensible part of my Emacs toolchain. This is
mostly a configuration of keys, but I also add =iy-go-to-char-start-pos= to the
=mc/cursor-specific-vars= list. This was recommended to me. The cursor specific
variables are, according to the =multiple-cursors= source, "a list of vars that
need to be tracked on a per-cursor basis."

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-c c" . mc/edit-lines)
         ("C-c >" . mc/mark-next-like-this)
         ("C-c <" . mc/mark-previous-like-this)
         ("C-c ?" . mc/mark-all-like-this))
  :config (add-to-list 'mc/cursor-specific-vars 'iy-go-to-char-start-pos))
#+END_SRC

For a good and easy-to-reproduce example of how powerful =multiple-cursors=
really is, go to the buffer list (~M-x~ =list-buffers=). Let's say you have
multiple Magit buffers open that you want to kill.

Search your way to the first Magit buffer, highlight the =*magit-= prefix,
and run =mc/mark-all-like-this=. Now you have a cursor on every Magit
buffer in the list. Now you can type ~k~ to mark every buffer with a cursor
on it for deletion. After disabling your multiple cursors with ~C-g~, you
can finally press ~x~ to make the buffer menu execute your instructions and
delete all Magit buffers.

Of course, this particular task is more easily done using a function like
=kill-matching-buffers= or even the Helm buffers list, but the routine
described above clearly illustrates the power of having multiple cursors.

** Search & replace: /visual-regexp/
:PROPERTIES:
:CUSTOM_ID: visual-regexp
:END:

*visual-regexp* is certainly worth a spot on the "interesting" packages list, not
only because its configuration is special, but because it is /just so good/. Not
only does it provide an incremental regex replace function - that means live
preview (!) - but the extension *visual-regexp-steroids* lets you search and
replace using PCRE instead of Emacs syntax (!).

To get this working with =use-package=, I first configure the plain old
/visual-regexp/ package, but tell =use-package= to /defer/ its loading - you see, for
/visual-regexp-steroids/ to work, it seems as though it needs to load
/visual-regexp/ itself. If you load it beforehand, it won't work.

Because =use-package= enables lazy-loading of packages when their configuration
includes a =:bind= option, we have to explicitly tell it to load
/visual-regexp-steroids/ immediately, regardless of the /:bind/-clause. This, again,
so that /visual-regexp/ won't load before its muscly brother.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :defer) ; prevent loading this package before visual-regexp-steroids!

(use-package visual-regexp-steroids
  :ensure pcre2el ; much faster than Python
  :demand ; load this package immediately, regardless of :bind
  :bind (("C-c r" . vr/replace)
         ("C-c q" . vr/query-replace)
         ("C-c m" . vr/mc-mark)
         ("C-M-r" . vr/isearch-backward)
         ("C-M-s" . vr/isearch-forward))
  :config (setq vr/engine 'pcre2el))
#+END_SRC

I got this solution from [[https://github.com/benma/visual-regexp-steroids.el/issues/16#issue-123951566][a workaround]] posted by GitHub user /alamaison/.
Thank you!

To enable PCRE style regex, instead of the default Python style, I configure the
package to use /pcre2el/ as its engine.

An interesting function provided by /visual-regexp/ is =vr/mc-mark=. This
function integrates with the /multiple-cursors/ package to add a cursor to
every match to a regex search. Useful!

** Alignment
:PROPERTIES:
:CUSTOM_ID: alignment
:END:

*** Aligning comments

What follows is a function [[http://stackoverflow.com/a/20278032/305047][written by the user phils]] at StackOverflow. It is a
language-agnostic method of aligning comments. How useful!

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun align-comments-in-region (beginning end)
  "Align comments within marked region."
  (interactive "*r")
  (let (indent-tabs-mode align-to-tab-stop)
    (align-regexp beginning end (concat "\\(\\s-*\\)"
                                        (regexp-quote comment-start)))))

(global-set-key (kbd "C-c M-a") #'align-comments-in-region)
#+END_SRC

** Working with Lisp
:PROPERTIES:
:CUSTOM_ID: lisp
:END:

*** FIXME Paredit
:PROPERTIES:
:CUSTOM_ID: paredit
:END:

Paredit is a totally indispensible tool for editing Lisp code. It changes the
way you write Lisp, by replacing many built-in editing commands as well as
providing its own set of functions, for creating, re-arranging, splitting,
convoluting and deleting s-expressions.

My only problem with Paredit is that it replaces ~M-r~. I frequently use ~M-r~ to
quickly move the cursor around the screen, but Paredit overrides that keybinding
with =paredit-raise-sexp=. To fix this, as you can see below, I have created a new
keybinding, ~M-R~, and put it inside a =use-package= /:bind/-clause. This way, as long
as I have Paredit installed, =use-package= binds ~M-R~ to the original function of
~M-r~.

# FIXME: paredit-delete-indentation
# ------ Account for there being a comment on the joined line. Right now it will
#        end up before the comment on the upper line.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package paredit
  :init
  (autoload 'enable-paredit-mode
      "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
  (add-hook 'racket-mode-hook           #'enable-paredit-mode)

  :config
  (defun paredit-delete-indentation (&optional arg)
    "Handle joining lines that end in a comment."
    (interactive "*P")
    (let ((comment (delete-and-extract-comment (if arg 1 0))))
      (delete-indentation arg)
      (when comment
        (save-excursion
      	  (move-end-of-line 1)
          (insert " ")
          (insert comment)))))

  (defun paredit-newline-keep-comment (&optional arg)
    "Insert newline, but keep any potential comment on the
current line."
    (interactive "*P")
    (let ((comment (delete-and-extract-comment)))
      (paredit-newline)
      (when comment
        (save-excursion
          (forward-line -1)
      	  (move-end-of-line 1)
          (insert " ")
          (insert comment)))))

  (global-set-key [remap paredit-newline] #'paredit-newline-keep-comment)

  ;; Disable comment column
  (add-hook 'paredit-mode-hook (lambda () (setq-local comment-column 0)))

  ;; Disable keybindings already used
  (define-key paredit-mode-map (kbd "M-q") nil)

  :bind (("M-R" . move-to-window-line-top-bottom)
         ("M-^" . paredit-delete-indentation)
         ("M-Q" . paredit-reindent-defun)))
#+END_SRC

*** Aggressive indentation
:PROPERTIES:
:CUSTOM_ID: aggressive-indent
:END:

=aggressive-indent= is a package that makes Emacs indent all the things, all the
time. I personally only use it for Lisp modes.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :demand
  :init
  (defun enable-aggressive-indent-mode ()
    (aggressive-indent-mode))
  (add-hook 'emacs-lisp-mode-hook       #'enable-aggressive-indent-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-aggressive-indent-mode)
  (add-hook 'ielm-mode-hook             #'enable-aggressive-indent-mode)
  (add-hook 'lisp-mode-hook             #'enable-aggressive-indent-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-aggressive-indent-mode)
  (add-hook 'scheme-mode-hook           #'enable-aggressive-indent-mode)
  (add-hook 'racket-mode-hook           #'enable-aggressive-indent-mode))
#+END_SRC

*** Common Lisp indentation
:PROPERTIES:
:CUSTOM_ID: common-lisp-indent
:END:

I like using the =cl-lib= library, which adds a whole bunch of Common Lisp
functions, prefixed with /cl-/. Unfortunately, Emacs doesn't indent some of the
/cl-/ functions correctly. For that reason, I use the =common-lisp-indent-function=
instead of the normal =lisp-indent-function=.

This might break a few things, though. For me, it broke =use-package= intentation.
Luckily, you can change the indentation rules yourself, as demonstrated below.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(setf lisp-indent-function 'common-lisp-indent-function)

;; Fix custom indentation
(with-eval-after-load "cl-indent"
  (put 'use-package 'common-lisp-indent-function 1)
  (put 'use-package-as-one 'common-lisp-indent-function 1))
#+END_SRC

** Working with regions
:PROPERTIES:
:CUSTOM_ID: regions
:END:

*** /expand-region/
:PROPERTIES:
:CUSTOM_ID: expand-region
:END:

I spend a lot of space setting up the shortcuts for =expand-region=, because
it is very useful. The functions speak for themselves. I use many of them, as
I find =er/expand-region= to work somewhat poorly with Emacs Lisp - perhaps
Paredit interferes with it.

In my configuration, I use ~C-'~ as a prefix for all =expand-region=
keybindings, and /Shift/ as a modifier to mark outside instead of inside the
region.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind (("C-' r"  . er/expand-region)
         ("C-' w"  . er/mark-word)
         ("C-' '"  . er/mark-inside-quotes)
         ("C-' \"" . er/mark-outside-quotes)
         ("C-' p"  . er/mark-inside-pairs)
         ("C-' P"  . er/mark-outside-pairs)
         ("C-' c"  . er/mark-comment)
         ("C-' t"  . er/mark-inner-tag)
         ("C-' T"  . er/mark-outer-tag)
         ("C-' f"  . er/mark-defun)))
#+END_SRC

*** /wrap-region/
:PROPERTIES:
:CUSTOM_ID: wrap-region
:END:

=wrap-region= is a handy plugin that automatically surrounds your selection with the
corresponding pairs when typing "paired" characters, like ~'~, ~"~ and ~(~.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp :exports none
(use-package wrap-region
  :config (wrap-region-mode t))
#+END_SRC

** Opening line below and above
:PROPERTIES:
:CUSTOM_ID: smart-open-line
:END:

Every Vim user knows how useful the =o= and =O= commands are. =smart-open-line= and
=smart-open-line-above= are two functions, borrowed from Emacs Redux, that emulate
this behavior.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun smart-open-line () ; (courtesy of Emacs Redux)
  "Insert an empty line after the current line.
Position the cursor at beginning, according to current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))

(defun smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at beginning, according to current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline)
  (if (looking-at "[[:space:]]*$") ; remove indentation from old line
      (delete-horizontal-space))
  (forward-line -1)
  (indent-according-to-mode))
#+END_SRC

Personally, I use the following keybindings:

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-o") 'smart-open-line)
(global-set-key (kbd "M-O") 'smart-open-line-above)
#+END_SRC

Note, however, that if you use Emacs in a terminal, ~M-O~ will not work.

** Commenting lines
:PROPERTIES:
:CUSTOM_ID: commenting-lines
:END:

What follows is a function by Jason Viers at StackExchange. It makes it a bit
easier to comment either the current line or the current region.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun comment-dwim-line (&optional arg) ; (courtesy of Jason Viers @ SE)
  "Replacement for the comment-dwim command.
If no region is selected and current line is not blank and we are
not at the end of the line, then comment current line. Replaces
default behaviour of comment-dwim, when it inserts comment at the
end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position)
                                   (line-end-position))
    (comment-dwim arg)))

(global-set-key (kbd "C-;") 'comment-dwim-line)
#+END_SRC


* Movement

** Quickly jumping around
:PROPERTIES:
:CUSTOM_ID: jumping
:END:

Moving around using ~C-n~, ~C-p~, ~C-f~ and ~C-b~ is not only tiresome, but
probably quite [[#rsi][unergonomical]] as well. Under this section, I tell you about the
methods I use to quickly jump to any position in the current window.

*** /iy-go-to-char/
:PROPERTIES:
:CUSTOM_ID: iy-go-to-char
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package iy-go-to-char
  :bind (("M-m" . iy-go-to-char)
         ("M-M" . iy-go-to-char-backward)
         ("C-." . iy-go-to-char-continue)
         ("C-," . iy-go-to-char-continue-backward)))
#+END_SRC

*iy-go-to-char* is a simple tool that provides functionality like Vim's =f=
and =F=. Works well, without any problems.

*** /avy/
:PROPERTIES:
:CUSTOM_ID: avy
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands avy-isearch
  :init (global-set-key (kbd "M-'") nil) ; reset M-'
  :config (define-key isearch-mode-map (kbd "M-'") 'avy-isearch)
  :bind (("C-M-'"   . abbrev-prefix-mark) ; re-bind default M-'
         ("M-' M-'" . avy-goto-line)
         ("M-' '"   . avy-goto-char)
         ("M-' s"   . avy-goto-char-timer)
         ("M-' w"   . avy-goto-word-1)))
#+END_SRC

*avy* is the successor to /ace-jump-mode/. It lets you jump to things
visually, but using the keyboa-rd. Smart man who came up with the original
idea.

For /avy/ I have dedicated the ~M-'~ keybinding. The default function tied
to ~M-'~ I have remapped to ~C-M-'~.

** Moving between windows: /windmove/
:PROPERTIES:
:CUSTOM_ID: windmove
:END:

For the most part, especially when using Org-mode, I use the normal ~C-x o~ to
switch between windows, but sometimes when you have multiple windows open, it's
easier just to use =windmove=. It is a package that provides simple directional
movement between windows.

Personally, I use the default keybindings, which make use of /Shift/ in
combination with any of the arrow keys.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :init (windmove-default-keybindings))
#+END_SRC

** Moving to the beginning and end of a line
:PROPERTIES:
:CUSTOM_ID: beginning-end-of-line
:END:

These are two functions that make Emacs feel a lot more friendly, especially for
an old Vim user. The =smarter-move-beginning-of-line= is based heavily on the
function with the same name from Emacs Redux, but =smarter-move-end-of-line= is
mostly a creation of my own, with inspiration from the [[https://www.emacswiki.org/emacs/EndOfLineNoComments][EmacsWiki]]. It works
better and more reliably than any other solutions that I've seen.

To summarize the behavior of the functions, =smarter-move-beginning-of-line=
toggles between Vim's =$= and =0= (indentation and real BOL), whereas
=smarter-move-end-of-line= toggles between the last non-space character before any
comment and the real EOL.

If you use tabs, you might want to replace the space-based =skip-syntax-backward=
call with a regex that includes all whitespace.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun smarter-move-beginning-of-line (&optional &rest args)
  "Move point back to indentation of beginning of line.
Move point to the first non-whitespace character on this line. If
point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line. If ARG is not nil or 1, move forward
ARG - 1 lines first. If point reaches the beginning or end of the
buffer, stop there."
  (interactive "^p")
  (let ((arg (or (prefix-numeric-value current-prefix-arg) 1)))
    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-to-column 0))))) ; based on function from Emacs Redux

(defun smarter-move-end-of-line (&optional &rest args)
  "Move to the end of the line, but before any potential comment.
If already at the pre-comment end of line, move to the actual end
of line. If ARG is not nil or 1, move forward ARG - 1 lines
first. If point reaches the beginning or end of the buffer, stop
there."
  (interactive "^p")
  (let ((arg (or (prefix-numeric-value current-prefix-arg) 1)))
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (let ((bol-point (point)))
        (let ((comment-start (comment-search-forward (point-at-eol) t)))
          (if comment-start
              (progn (goto-char comment-start)
                     (skip-syntax-backward " " (point-at-bol)))
            (move-end-of-line 1)))
        (when (= orig-point (point))
          (move-end-of-line 1))))))
#+END_SRC

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(global-set-key [remap move-beginning-of-line]
                'smarter-move-beginning-of-line)
(global-set-key [remap move-end-of-line]
                'smarter-move-end-of-line)
#+END_SRC

** Scrolling pleasantly
:PROPERTIES:
:CUSTOM_ID: scrolling-pleasantly
:END:

Sometimes, the mouse is really useful. I love text-based interfaces, but they're
not perfect. Lucky for me, Emacs has good mouse support, at least in the GUI
version.

An annoying thing about using the mouse in Emacs, however, is scrolling. It
works well most of the time, until you hit the beginning or end of the buffer.
BEEP! If you haven't disabled the bell, you'll hear the bell. If you have
disabled the bell, you'll see an annoying /visual/ bell. Yes, I know that I've
enabled the visual bell myself, and I do like it. Just not when I'm scrolling.

The following code surpresses any errors thrown by =mwheel-scroll=.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun silent-mwheel-scroll (oldfun &rest r)
  (interactive (list last-input-event))
  (ignore-errors
    (call-interactively oldfun)))

(advice-add #'mwheel-scroll :around #'silent-mwheel-scroll)
#+END_SRC

Much better! Funny how one small change can make Emacs feel ten years more
modern.


* Visual aids

** Folding with /origami/
:PROPERTIES:
:CUSTOM_ID: origami
:END:

Origami is a package that provides Vim-like folding. I have been an avid
Vim user, so folding is a natural part of my programming life.

The configuration that follows is /long/. I will therefore stop every now
and then, take a pause and explain what I've done:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package origami
  :config
  (global-origami-mode t)

  (defun traverse-folds (times &optional beginning)
    "Traverses through folds as many times as ordered by argument.
A negative argument makes it traverse backwards."
    (if (> times 0)
        (move-end-of-line nil)
      (move-beginning-of-line nil))
    (let ((fun (if (> times 0) 'origami-forward-fold 'origami-previous-fold))
          (beginning (or beginning (point))))
      (dotimes (i (abs times))
        (condition-case err
            (funcall fun (current-buffer) (point))
          (error (message "Fold not found: %s" err))))
      (set-mark beginning)
      (deactivate-mark)))

  (defun next-fold (times)
    "Jumps to the beginning of the next fold (or previous, on
negative argument)."

    (interactive "P")
    (unless times (setq times 1))
    (traverse-folds times))

  (defun previous-fold (times)
    "Jumps to the beginning of the previous fold, as many times
as ordered by argument."
    (interactive "P")
    (unless times (setq times 1))
    (next-fold (* times -1)))

  (defun goto-fold (number)
    "Jumps to fold # (provided by argument) in file."

    (interactive "P")
    (let ((number (or number (string-to-number (read-string "Jump to fold: "))))
          (beginning (point)))
      (if (equal number 0) (setq number 1))
      (if (> number 0)
          (goto-char (point-min))
        (goto-char (point-max)))
      (traverse-folds number beginning)))

  ;; Above are listed my own functions for traversing folds. I have functions
  ;; for going to the next, previous and nth fold, but they're all based on one
  ;; =traverse-folds= function. The reason I wrote my own function was that the
  ;; functions built into /origami/ didn't exactly work the way I wanted. They
  ;; would jump from fold end to fold end when jumping forwards - very annoying.

  :bind (("M-Z"     . custom-origami-toggle-node)
         ("C-M-z"   . origami-toggle-all-nodes)
         ("C-c C-z" . goto-fold)
         ("C-c C-n" . next-fold)
         ("C-c C-p" . previous-fold)))
#+END_SRC

Finally, some simple keybidnings, including ones for normal Origami
functions as well as for the above-defined custom functions.

In summary, it's a shame that this much configuration is needed to get such
a simple feature like folding working, especially when Vim supports it
almost perfectly from scratch. Overall, folding just doesn't seem to work
reliably in Emacs outside of Org-mode.

** Highlighting superfluous whitespace
:PROPERTIES:
:CUSTOM_ID: show-trailing-whitespace
:END:

With the following code, I enable highlighting of trailing whitespace in any
buffer whose mode descends from /prog-mode/.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda ()
                            (setq-local show-trailing-whitespace t)))
#+END_SRC

** Dynamic cursor shape
:PROPERTIES:
:CUSTOM_ID: dynamic-cursor-shape
:END:

One of the things I struggle with while using Emacs is identifying which window
is currently active. Highlighting the mode line helps, but it's usually not
enough for me. Previously, I have used =hl-line= with success, but I found that
the package was quite unoptimized and that it didn't play nice with some modes.

One of the solutions I have found is setting the cursor shape differently for
focused and unfocused windows.

I define the following functions to change the cursor shape to a hollow block
when a window becomes unfocused, and back to the default shape (that is, the
current cursor type when Emacs ran my configuration) when a window becomes
focused.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defvar default-cursor-shape cursor-type)

(defun cursor-focused ()
  (setq-local cursor-type default-cursor-shape))
(defun cursor-unfocused ()
  (setq-local cursor-type 'block))
#+END_SRC

The above functions are called from a function called =cursor-set-focus=, which is
added to =post-command-hook=. It loops through all of the frame's windows and
calls =cursors-focused= if the window's buffer matches the current buffer.
Otherwise it calls =cursor-unfocused=.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun cursor-set-focus ()
  (cl-loop
   for window in (window-list)
   do (let ((current-buffer (window-buffer)))
        (with-current-buffer (window-buffer window)
          (if (equal (window-buffer window) current-buffer)
              (cursor-focused)
            (cursor-unfocused))))))

(add-hook 'post-command-hook 'cursor-set-focus)
#+END_SRC

This is a pretty nice way of checking the active window. I am usually against
using =post-command-hook=, because of how often it is run, but there isn't
anything as reliable. Believe me, [[#custom-hooks][I've tried]].

** Prettify symbols mode

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'prettify-symbols-mode)
#+END_SRC

** /which-key/

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :config
  ;; Use minibuffer instead of window (note: this sets `which-key-popup-type'
  ;; automatically to `minibuffer')
  ;; (which-key-setup-minibuffer)
  )
#+END_SRC


* Helpful tools

** Helm
:PROPERTIES:
:CUSTOM_ID: helm
:END:

I always feel a bit guilty when I use Helm. Which is, like, all the time,
because of how useful it is. I mostly use Helm "as-is." I do have some code that
implements Helm completion from Eshell, which is very useful.

I have used alternatives to Helm, like Ido and Ivy, but I felt that Ido provided
too little, and that Ivy made things surprisingly complicated. Want to close all
Magit buffers? With Helm, you just enter "magit", hit ~<C-space>~ a few times and
then ~M-D~. With Ivy, you'd have to find the first buffer to delete, then hit
~C-M-o~ (instead of the normal ~C-o~ that's in your muscle memory) and ~k~ to kill the
/first/ buffer. Then repeat it all those keystrokes for all remaining buffers.

Another thing I never liked about Ivy was its =describe-function= and
=describe-variable= integration. You would need to have your cursor /right next to/
the function or variable name in order to look it up, whereas with Helm, you can
be anywhere in the s-expression.

Helm is big, but it does its job /very/ well, and it makes common actions /very/
simple. Ivy is evidence that smaller doesn't always mean simpler.

*Update:* I have reverted back to my old configuration to give Ivy a second
chance. I've gotten a bit more used to it now - there are some things I still
don't like about it, but for now, I'll keep using it. Thus, I've disabled Helm
below, using the /:disabled/ keyword.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package helm
  :disabled
  :commands helm-command-prefix
  :bind (("M-x"     . helm-M-x)
         ("C-x C-f" . helm-find-files)
         ("C-x C-b" . helm-mini))

  :init
  (global-set-key (kbd "C-c C-h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))
  (require 'helm-config)
  (helm-mode 1)
  (helm-flx-mode 1)

  :config
  ;; Projectile integration
  (setq projectile-completion-system 'helm)
  (setq projectile-switch-project-action 'helm-projectile)
  (helm-projectile-on)

  ;; Eshell completion
  (with-eval-after-load 'eshell
    (add-hook 'eshell-mode-hook
              (lambda ()
                (eshell-cmpl-initialize)
                (define-key eshell-mode-map [remap eshell-pcomplete] #'helm-esh-pcomplete)))))
#+END_SRC

** Ivy
:PROPERTIES:
:CUSTOM_ID: ivy
:END:

# TODO: documentation

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :init
  (ivy-mode 1)
  :config
  (setq ivy-use-virtual-buffers t)
  (setq enable-recursive-minibuffers t)
  (setq ivy-re-builders-alist
        '((swiper . ivy--regex-plus)
          (t . ivy--regex-fuzzy)))

  :bind (("C-s"     . swiper)

         ("C-c C-r" . ivy-resume)
         ("<f6>"    . ivy-resume)

         ("M-x"     . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("<f1> f"  . counsel-describe-function)
         ("<f1> v"  . counsel-describe-variable)
         ("<f1> l"  . counsel-find-library)
         ("<f2> i"  . counsel-info-lookup-symbol)
         ("<f2> u"  . counsel-unicode-char)
         ("C-c k"   . counsel-ag)

         ("C-x l"   . counsel-locate)
         ("C-x b"   . ivy-switch-buffer)
         ("C-x C-b" . ibuffer))
  :bind (:map read-expression-map
              ("C-r" . counsel-expression-history)))

(use-package counsel
  :bind
  ;; Courtesy of Pragmatic Emacs
  ;; (see http://pragmaticemacs.com/emacs/counsel-yank-pop-with-a-tweak/)
  (("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))

(use-package counsel-projectile
  :init
  (counsel-projectile-on))
#+END_SRC

*** /counsel-everything/
:PROPERTIES:
:CUSTOM_ID: counsel-everything
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ivy
  ;; TODO: Add support for ignoring absolute paths

  (defun counsel-everything (&optional dir)
    "Find all files in the current directory, including subdirectories.
If DIR is non-nil, use that directory instead of current one.

From the minibuffer, C-<backspace> can be pressed to go up a
directory, relative to DIR. Note that by default, you cannot go
up to /, as processing this directory takes a long time and is
rarely desirable."
    (interactive)
    (let* ((dir (or dir "."))
           (abs-path (file-truename dir))
           (dir-name (file-name-nondirectory (directory-file-name abs-path)))
           (ignored-dirs '("*/.git"
                           "*/elpa"
                           "*/state"))
           (ignored-dirs-string (mapconcat
                                 (lambda (dir)
                                   (concat "-not \\( -path '" dir "' -prune \\)"))
                                 ignored-dirs " "))
           (candidates (mapcar
                        (lambda (file)
                          (if (equal dir file)
                              nil
                            (if (string-prefix-p "find: " file)
                                ;; Ignore errors from `find' (usually about
                                ;; permissions):
                                nil
                              (string-remove-prefix (concat dir "/") file))))
                        (split-string
                         (shell-command-to-string (concat "find " dir " "
                                                          ignored-dirs-string))
                         "\n" t))))
      (setf counsel-everything--dir dir) ; set global dir value (for counsel-everything-up-directory)
      (ivy-read (format "(%s) Find everything: " dir-name) candidates
                :matcher #'counsel--find-file-matcher
                :action (lambda (file)
                          (with-ivy-window
                            (find-file (expand-file-name file counsel-everything--dir))))
                :keymap (make-counsel-everything-map)
                :require-match 'confirm-after-completion
                :caller #'counsel-everything)))

  (ivy-set-actions
   #'counsel-everything
   '(("j" find-file-other-window "other window")
     ("x" counsel-find-file-extern "open externally")
     ("r" counsel-find-file-as-root "open as root")))

  (defvar counsel-everything--dir nil
    "Internal variable used by counsel-everything-up-directory.")

  (defun make-counsel-everything-map ()
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-DEL")         #'counsel-everything-up-directory)
      (define-key map (kbd "C-<backspace>") #'counsel-everything-up-directory)
      map))

  (defun counsel-everything-up-directory ()
    (interactive)
    (let ((dir "")
          (up-dir))
      (if (and (boundp 'counsel-everything--dir)
               (not (equal counsel-everything--dir ".")))
          (setf dir (concat counsel-everything--dir "/")))
      (setf up-dir (format "%s.." dir))
      (unless (string-equal (file-truename up-dir) "/")
        (eval `(run-at-time nil nil
                            (lambda ()
                              (counsel-everything ,up-dir))))
        (minibuffer-keyboard-quit))))

  (global-set-key (kbd "C-x C-M-f") #'counsel-everything))
#+END_SRC
** Swiper
:PROPERTIES:
:CUSTOM_ID: swiper
:END:

All right, so I know I said I didn't like Ivy, but I do like Swiper, which uses
Ivy. It's far better than both =isearch= and =helm-occur=. That said, if you know
about a package with equivalent functionality, but for Helm, please let me know!

The following configuration sets up Swiper to use ~C-s~. I also set up Ivy, since
Swiper requires Ivy and =swiper-helm= didn't work, but I /defer/ its loading until
it's needed by Swiper.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
;; (use-package ivy
;;   :defer t)

(use-package swiper
  :bind (("C-s" . swiper)))
#+END_SRC

** Projectile
:PROPERTIES:
:CUSTOM_ID: projectile
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-global-mode)
  (setq projectile-enable-caching t)
  (setq projectile-require-project-root nil)

  (setq projectile-globally-ignored-directories
        (cl-list* ".cache" ".cargo"
                  projectile-globally-ignored-directories)))
#+END_SRC

Projectile is a package that I use for two reasons: the Helm integration
and the file finder.

** Magit
:PROPERTIES:
:CUSTOM_ID: magit
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-c g"   . magit-status))
#+END_SRC

The fact that *magit* requires this little configuration, yet is so
incredibly useful, is a testament to good design. The only thing I could
possibly complain about is the speed. It does run slow on my computer. I
hope it's just because I'm running it on the Windows Subsystem for Linux.

** Eshell
:PROPERTIES:
:CUSTOM_ID: eshell
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 4 e") ; open eshell in split to the right
                (lambda ()
                  (interactive)
                  (split-window-right)
                  (other-window 1)
                  (eshell)))
#+END_SRC

** /git-gutter+/
:PROPERTIES:
:CUSTOM_ID: git-gutter
:END:

As much as I love Magit, it's big, unwieldy and a bit slow. When editing my
Emacs configuration, I find that I postpone staging and commiting my changes,
lating having to do it all at once. It's annoying.

=git-gutter+= is an excellent package that lets me stage individual hunks of
changes without even leaving the buffer of the edited file. It works by
displaying plus and minus signs left of the fringe, indicating what lines have
been changed.

Just because it is so useful, I dedicate the prefix ~C-M-g~ to all =git-gutter+=
commands.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package git-gutter+
  :bind (("C-M-g C-M-g" . git-gutter+-mode))
  :bind (:map git-gutter+-mode-map
              ("C-M-g n" . git-gutter+-next-hunk)
              ("C-M-g p" . git-gutter+-previous-hunk)
              ("C-M-g d" . git-gutter+-show-hunk)
              ("C-M-g r" . git-gutter+-revert-hunks)
              ("C-M-g s" . git-gutter+-stage-hunks)
              ("C-M-g c" . git-gutter+-commit)))
#+END_SRC

The only problem I have with the package is that it doesn't use the actual
fringe. I have tried the extension =git-gutter+-fringe=, but I never got it to
work. Perhaps it needs updating, I don't know. For now, =git-gutter+= works fine.
** /openwith/
:PROPERTIES:
:CUSTOM_ID: openwith
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package openwith
  :init
  (openwith-mode t)
  (setq openwith-associations '(("\\.pdf\\'" "mupdf" (file)))))
#+END_SRC

*openwith* is a nice little plugin that does one thing very well. It tells Emacs
to open certain files in external programs. I personally use /mupdf/ for all my
PDF reading.


* Modes

** Org
:PROPERTIES:
:CUSTOM_ID: org-mode
:END:

Org-mode is where I spend much of my Emacs time. I use it for writing, studying,
planning and, of course, configuring Emacs. My configuration began small but
as I've begun to use it more it has just kept growing.

This is the main configuration. You'll see a few references to custom =org-=
functions - they are defined further down.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package org
  :mode (("\\.org$" . org-mode))
  :ensure org-plus-contrib
  :demand
  :config
  ;; Make ' and " work in inline code
  (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\r\n,")
  (org-set-emph-re 'org-emphasis-regexp-components
                   org-emphasis-regexp-components) ; reload setting

  ;; Make windmove work in org-mode (not very useful)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)

  ;; Export to exports/ subdirectory
  (defun /org-export-to-subdirectory (orig-fun &rest args)
    (shell-command (concat "mkdir -p exports"))
    (apply orig-fun
           (pop args)                     ; backend
           (concat "exports/" (pop args)) ; file
           args))
  (advice-add #'org-export-to-file :around #'/org-export-to-subdirectory)

  ;; Remove keybindings that I already use
  (define-key org-mode-map (kbd "C-'") nil)

  ;; Enable for all Org files
  (add-hook 'org-mode-hook #'swedish-mode) ; Swedish letters
  (add-hook 'org-mode-hook #'org-autolist-mode) ; better list behavior

  :bind (("C-c o a" . org-agenda)
         ("C-c o l" . org-store-link)
         ("C-c o c" . org-capture)
         ("C-c o b" . org-iswitchb)))
#+END_SRC

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp :noweb yes :exports none
(with-eval-after-load 'org
  <<c:org:fun>>
)
#+END_SRC

*** FIXME /org-tree-view/
:PROPERTIES:
:CUSTOM_ID: org-tree-view
:END:

Sometimes, I use to write large documents with many headings and many levels.
Sometimes, keeping track of it all requires a substantial amount of brain power.
Wouldn't it be great to have a small outline to the left of the text, where you
could select a section and narrow in on it in a big window to the right?

That's what the =org-tree-view= functions are for. They started out as carbon
copies of two answers on the Emacs StackExchange, by [[https://emacs.stackexchange.com/a/9532][Dan]] and [[https://emacs.stackexchange.com/a/14987][blujay]]
respectively, but they have developed into something quite solid.

#+CAPTION: /org-tree-view/ in combination with the theme /leuven/
#+NAME: fig:org-tree-view
[[./resources/org-tree-view-new.png]]

It works by opening a clone of the current Org buffer in a new window to the
left. The cloned buffer, called the /tree view/, has the following properties:

- It displays nothing but headings
- On ~<return>~ or ~<mouse-1>~, the heading at point is opened in the /base buffer/ and
  the base buffer is narrowed to the subtree of the heading
- When you open a heading, you can press the same key again, within one second of
  delay, to close the tree view behind you
- On =<tab>=, visibility is toggled between all headings and the levels of
  headings set in =org-tree-view/levels= (default: 3)
- On ~Q~, the tree view is closed and its buffer deleted
- On any other non-modifier key, it automatically starts searching through the
  headings (but, crucially, not the rest of the text) using =isearch=
- Within =isearch=, ~<S-return>~ opens the currently selected matching heading in
  the base buffer

#+NAME: c:org:fun
#+BEGIN_SRC emacs-lisp :noweb yes :exports none
<<c:org-tree-view>>
#+END_SRC

**** Minor mode definition

#+NAME: c:org-tree-view
#+BEGIN_SRC emacs-lisp
(defvar org-tree-view-mode-map (make-sparse-keymap))

(define-key org-tree-view-mode-map (kbd "<return>")  #'org-tree-view/open-headline-at-point)
(define-key org-tree-view-mode-map (kbd "<mouse-1>") #'org-tree-view/open-headline-at-point)
(define-key org-tree-view-mode-map (kbd "C-g")       #'org-tree-view/close)
(define-key org-tree-view-mode-map (kbd "<tab>")     #'org-tree-view/toggle-visibility)
(define-key org-tree-view-mode-map [remap end-of-buffer]
  (lambda () (interactive) (goto-char (point-max)) (move-beginning-of-line 1)))

;; Re-define self-insert-command
(map-keymap (lambda (key fun)
              (if (equal fun #'self-insert-command)
                  ;; Append ((from . to) #'org-tree-view/self-insert-command))
                  (nconc org-tree-view-mode-map
                        (list (cons key #'org-tree-view/self-insert-command)))))
            (current-global-map))
(setq org-tree-view-mode-map ; develop (from . to) ranges, please
      (keymap-canonicalize org-tree-view-mode-map))

(define-minor-mode org-tree-view-mode
  ""
  nil
  :lighter " tree-view"
  org-tree-view-mode-map)

(provide 'org-tree-view-mode)
#+END_SRC

**** Rendering the tree view

#+NAME: c:org-tree-view
#+BEGIN_SRC emacs-lisp
(require 'subr-x)

(defun org-tree-view/get-headlines (&optional level &optional base-buffer)
  "Get a list of all headlines in `base-buffer' of a level less
than or equal to provided `level'. Includes headlines outside of
any potential narrowing."
  (let ((level (or level org-tree-view/level))
        (base-buffer
         (or base-buffer
             (if (org-tree-view/is-tree-view)
                 (get-buffer (org-tree-view/make-base-buffer-name))
               (current-buffer))))
        (headlines))
    (with-current-buffer base-buffer
      (let ((widened-buffer
             (clone-indirect-buffer
              (concat "<widened>" (buffer-name base-buffer)) nil)))
        (with-current-buffer widened-buffer
          (widen)
          (setq headlines (org-element-map (org-element-parse-buffer 'headline) 'headline
                            (lambda (headline)
                              (when (<= (org-element-property :level headline) level)
                                headline)))))
        (kill-buffer widened-buffer)))
    headlines))

(defun org-tree-view/draw-headline (headline)
  "Return a string of the headline to be printed, with the proper
face and its position in the base buffer encoded as the
`org-tree-view-headline-pos' text property."
  (let* ((title (org-element-property :raw-value headline))
         (level (org-element-property :level headline))
         (begin (org-element-property :begin headline))
         (end (org-element-property :end headline))
         (org-tree-view-level-face (intern
                                    (concat "org-tree-view/level-"
                                            (number-to-string level))))
         (text (concat (apply #'concat (make-list (* 2 (1- level)) " "))
                       "* "
                       (replace-regexp-in-string "\"" "" title nil t)))) ; remove \" from title

    ;; Text properties
    (put-text-property ; org-tree-view-level-N
     0 (length text)
     'font-lock-face org-tree-view-level-face
     text)
    (put-text-property ; encode headling position in base buffer
     0 (length text)
     'org-tree-view-headline-pos begin
     text)
    (setq text (org-tree-view/draw-string text))

    ;; Pad headline with spaces
    (let ((end (1- (length text))))
      (setq text (concat text
                         (apply #'concat (make-list (* 2 org-tree-view/width) " "))))
      ;; Add same properties to padding (a little repetitive)
      (put-text-property
       end (length text)
       'font-lock-face org-tree-view-level-face
       text)
      (put-text-property
       end (length text)
       'org-tree-view-headline-pos begin
       text))
    text))

(defun org-tree-view/draw-string (text)
  "Apply the appropriate faces on `text' according to Org markup
syntax and return the resulting string."
  (let* ((types '(link
                  italic
                  bold
                  strike-through
                  verbatim
                  code))
         (data (org-element-parse-secondary-string text types)))
    (org-element-map data types
      (lambda (object)
        (let* ((type (org-element-type object))
               (begin (1- (org-element-property :begin object)))
               (end (1- (org-element-property :end object)))
               (faces
                '(italic         italic
                  bold           bold
                  strike-through (:strike-through t)
                  verbatim       org-verbatim
                  code           org-code)))

          ;; Figure out real end of object
          (let ((substr (string-trim-right (substring text begin end))))
            (setq end (+ begin (length substr))))

          ;; Handle faces
          (when (member type faces)
            (let* ((face (plist-get faces type))
                   (existing-face (get-text-property begin 'font-lock-face text))
                   (new-face (if existing-face
                                 `(,face ,existing-face)
                               face)))
              (put-text-property ; add face for type
               begin end
               'font-lock-face new-face
               text))
            (put-text-property ; remove first piece of markup
             begin (1+ begin)
             'display ""
             text)
            (put-text-property ; remove second piece of markup
             (1- end) end
             'display ""
             text))

          ;; Handle links
          (when (equal 'link type)
            (let ((contents-begin (org-element-property :contents-begin object)))
              (if contents-begin ; has contents
                  (put-text-property
                   begin (1- contents-begin)
                   'display ""
                   text)
                (put-text-property ; only url
                 begin (+ begin 2)
                 'display ""
                 text))
              (put-text-property
               (- end 2) end
               'display ""
               text))))))
    text))

(defun org-tree-view/insert-headlines ()
  "Insert all drawn headlines at the current position."
  (let ((headlines (org-tree-view/get-headlines)))
    (cl-loop for headline in headlines
       do (insert (concat
                   (org-tree-view/draw-headline headline)
                   "\n")))
    ;; Delete final newline
    (backward-delete-char 1)))

(defun org-tree-view/refresh (&optional no-set-window-start)
  (let* ((orig-window-start (window-start))
         (orig-window-line  (+ (count-lines (window-start) (point))
                               (if (= (current-column) 0) 1 0)
                               -1))
         ;; ^ see http://www.delorie.com/gnu/docs/elisp-manual-21/elisp_478.html
         (refresh `(progn
                     (setq-local buffer-read-only nil)
                     (set-window-fringes (get-buffer-window) 8 1)
                     (erase-buffer)
                     (org-tree-view/insert-headlines)
                     (set-window-start (get-buffer-window) orig-window-start)
                     (goto-char (window-start))
                     (forward-line orig-window-line)
                     (move-beginning-of-line 1)
                     (setq-local buffer-read-only t))))
    (if (org-tree-view/is-tree-view)
        (eval (macroexpand refresh))
      (if (org-tree-view/has-tree-view)
          (with-current-buffer (org-tree-view/make-tree-view-buffer-name)
            (eval (macroexpand refresh)))))))
#+END_SRC

**** Interacting with the tree view

#+NAME: c:org-tree-view
#+BEGIN_SRC emacs-lisp
(defun org-tree-view/open (&optional arg)
  ""
  (interactive "p")
  (let ((tree-view-buffer-name (org-tree-view/make-tree-view-buffer-name))
        (base-buffer (current-buffer))
        (tree-view-buffer))

    (if (and (org-tree-view/has-tree-view)
             (get-buffer-window tree-view-buffer-name))
        (progn
          (select-window (get-buffer-window tree-view-buffer-name))
          (setq tree-view-buffer (get-buffer tree-view-buffer-name)))
      (if (org-tree-view/has-tree-view)
          (kill-buffer (org-tree-view/make-tree-view-buffer-name)))
      (if (equal org-tree-view/side 'left)
          (split-window-right org-tree-view/width)
        (split-window-right (* -1 org-tree-view/width))
        (other-window 1))
      (setq tree-view-buffer (generate-new-buffer tree-view-buffer-name)))

    ;; Switch to tree view buffer
    (switch-to-buffer tree-view-buffer)
    (org-tree-view/setup)
    (org-tree-view-mode)))

(defun org-tree-view/close (&optional tree-view-buffer &optional base-buffer)
  "Close `tree-view-buffer' for `base-buffer'. Defaults to the current buffer."
  (interactive)
  (let* ((base-buffer
          (get-buffer (or base-buffer
                          (if (org-tree-view/is-tree-view)
                              (org-tree-view/make-base-buffer-name)
                            (current-buffer)))))
         (tree-view-buffer
          (get-buffer (or tree-view-buffer
                          (org-tree-view/make-tree-view-buffer-name base-buffer))))
         (tree-view-window))
    (if tree-view-buffer
        (progn (if (setq tree-view-window (get-buffer-window tree-view-buffer))
                   (delete-window tree-view-window))
               (kill-buffer tree-view-buffer)
               (org-tree-view/cleanup))
      (error "No tree view found!"))))

(defun org-tree-view/bind-close-after (&optional key)
  "Bind the key combination pressed to call
`org-tree-view/open-headline-at-point' to also close the tree
view, but only for 1 second."
  (let* ((key (or key (this-command-keys-vector)))
         (original-binding (local-key-binding key))
         (reset-key `(local-set-key ,key (quote ,original-binding)))
         (base-buffer))
    (if (org-tree-view/is-tree-view)
        (setq base-buffer (org-tree-view/make-base-buffer-name))
      (if (org-tree-view/has-tree-view)
          (setq base-buffer (current-buffer))))
    (when (and base-buffer (not (string-match-p "mouse" (key-description key))))
      (message "Press %s again to close the tree view." (key-description key))
      (eval
       (macroexpand
        `(progn
           (local-set-key ,key (lambda () (interactive)
                                 ,reset-key
                                 (org-tree-view/close)))
           (run-with-timer 1 nil (lambda ()
                                   (message " ") ; clear
                                   (with-current-buffer ,base-buffer
                                     ,reset-key)))))))))

(defun org-tree-view/open-headline-at-point (&optional bind-close-after)
  "From tree view, open headline at point in base buffer. If
`bind-close-after' is non-nil (default: t), the function will
also call `org-tree-view/bind-close-after' before finishing."
  (interactive)
  (let* ((bind-close-after (or bind-close-after t))
         (base-buffer (org-tree-view/make-base-buffer-name))
         (position (get-text-property (point) 'org-tree-view-headline-pos)))
    (condition-case nil
        (select-window (car (get-buffer-window-list base-buffer)))
      (error (other-window 1)
             (switch-to-buffer base-buffer)))
    (if position
        (progn (widen)
               (goto-char position)
               (outline-show-all)
               (org-cycle-hide-drawers 'all)
               (org-narrow-to-subtree)
               (if bind-close-after (org-tree-view/bind-close-after)))
      (error "No headline found!"))))

(defun org-tree-view/switch-to-base-buffer ()
  (interactive)
  (when (org-tree-view/is-tree-view)
    (if (get-buffer-window (org-tree-view/make-base-buffer-name))
        (select-window (get-buffer-window (org-tree-view/make-base-buffer-name)))
      (other-window 1)
      ;; FIXME: the following switch-to-buffer didn't work last I checked
      (switch-to-buffer (org-tree-view/make-base-buffer-name) nil :force-same-window))))

(defun org-tree-view/toggle-visibility (&optional arg)
  (interactive "P")
  (if (numberp arg)
      (setq-local org-tree-view/level arg)
    (if (/= org-tree-view/level (default-value 'org-tree-view/level))
        (setq-local org-tree-view/level (default-value 'org-tree-view/level))
      (setq-local org-tree-view/level 2)))
  (org-tree-view/refresh :no-set-window-start))
#+END_SRC

***** Searching the tree view

#+NAME: c:org-tree-view
#+BEGIN_SRC emacs-lisp
(defun org-tree-view/self-insert-command (N)
  "Start an `isearch' with the character `N' as the first
character in the search."
  (interactive "p")
  (goto-char (point-min))
  (let* ((char (string-to-char (this-command-keys)))
         (unread-command-events (append unread-command-events (list char))))
    (isearch-forward)))

(defun org-tree-view/isearch-return ()
  "Open the matching headline and exit the isearch."
  (interactive)
  (when (org-tree-view/is-tree-view)
    (org-tree-view/open-headline-at-point)
    (run-with-timer 0 nil (lambda () (org-tree-view/bind-close-after (kbd "<S-return>"))))
    ;; ^ Timer needed because isearch-exit behaves weirdly otherwise.
    (let ((inhibit-message t))
      (isearch-exit))))
#+END_SRC

**** Helper functions

#+NAME: c:org-tree-view
#+BEGIN_SRC emacs-lisp
(defun org-tree-view/setup ()
  (font-lock-mode)
  (org-tree-view/refresh)
  (setq-local buffer-read-only t)
  (setq-local scroll-margin 0)
  (setq-local case-fold-search t) ; ignore case
  (define-key isearch-mode-map (kbd "<S-return>") #'org-tree-view/isearch-return))

(defun org-tree-view/cleanup ()
  (define-key isearch-mode-map (kbd "<S-return>") nil))

(defun org-tree-view/make-base-buffer-name (&optional tree-view-buffer)
  (let ((tree-view-buffer
         (get-buffer (or tree-view-buffer
                         (current-buffer)))))
    (string-remove-prefix "<tree>" (buffer-name tree-view-buffer))))

(defun org-tree-view/make-tree-view-buffer-name (&optional base-buffer)
  (let ((base-buffer
         (get-buffer (or base-buffer
                         (current-buffer)))))
    (concat "<tree>" (buffer-name base-buffer))))

(defun org-tree-view/is-tree-view (&optional buffer)
  (let ((buffer (or buffer (current-buffer))))
    (with-current-buffer buffer
      (bufferp (get-buffer (org-tree-view/make-base-buffer-name buffer))))))

(defun org-tree-view/has-tree-view (&optional buffer)
  (let ((buffer (or buffer (current-buffer))))
    (with-current-buffer buffer
      (bufferp (get-buffer (org-tree-view/make-tree-view-buffer-name buffer))))))
#+END_SRC

**** Customizable options

With /org-tree-view/ looking more and more like a package, there are of course
options that can be set:

#+NAME: c:org-tree-view
#+BEGIN_SRC emacs-lisp
(defgroup org-tree-view nil
  "A window providing easy access to all headings in an Org document."
  :group 'org-mode)

(defcustom org-tree-view/level 3
  "The highest level headings to show in the tree view. Think of
each asterisk preceding a heading as a level."
  :group 'org-tree-view
  :type 'integer)

(defcustom org-tree-view/width 30
  "The width of the tree view window."
  :group 'org-tree-view
  :type 'integer)

(defcustom org-tree-view/side 'left
  "The side on which to open the tree view window."
  :group 'org-tree-view
  :type '(radio
          (const :tag "Left" left)
          (const :tag "Right" right)))

(defcustom org-tree-view/open-key-binding "C-c C-t"
  "The key binding to open the tree view."
  :group 'org-tree-view
  :type 'string
  :set (lambda (option value)
         (define-key org-mode-map (kbd value)
           #'org-tree-view/open)
         (define-key org-tree-view-mode-map (kbd value)
           #'org-tree-view/switch-to-base-buffer)))

;; Define org-tree-view/level-N faces
(dotimes (i 8)
  (let* ((num (number-to-string (1+ i)))
         (org-tree-view-face (intern (concat "org-tree-view/level-" num)))
         (org-face (intern (concat "org-level-" num))))
    (eval (macroexpand
           `(defface ,org-tree-view-face
              '((t . (:inherit ,org-face)))
              (format "Face for level %s headlines." num))))))
#+END_SRC

**** Issues

- Currently, after making edits with the tree view open, it seems that
  =org-tree-view/open-headline-at-point= will, for many headlines, move to the
  wrong position in the base buffer. Upon closing and re-opening the tree view,
  the bug disappears.

**** Planned features

- Keyword integration (TODO, DONE, ...)

*** Publishing my blog through /org-page/
:PROPERTIES:
:CUSTOM_ID: org-page
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package org-page
  :config
  (setf op/hashover-comments t))
#+END_SRC

*** Automatic Wiktionary links
:PROPERTIES:
:CUSTOM_ID: org-make-wiktionary-link
:END:

#+NAME: c:org:fun
#+BEGIN_SRC emacs-lisp
(defun org-make-wiktionary-link (string &optional from to)
  "Wraps the word at point or selected word in a Wiktionary link to the word."

  ;; (see http://ergoemacs.org/emacs/elisp_command_working_on_string_or_region.html)
  (interactive
   (if (use-region-p)
       (list nil (region-beginning) (region-end))
     (let ((bds (bounds-of-thing-at-point 'word)) )
       (list nil (car bds) (cdr bds)))))

  (let ((wiktionary-language
         (if (boundp 'wiktionary-language) wiktionary-language 'russian)))

    (let* ((input  (or string (buffer-substring-no-properties from to)))
           (output (concat "[[https://en.wiktionary.org/wiki/"
                           (org-link-escape (downcase input))
                           "#"
                           (capitalize (symbol-name wiktionary-language))
                           "]["
                           input
                           "]]")))
      (delete-region from to)
      (goto-char from)
      (insert output))))

(define-key org-mode-map (kbd "C-c L") #'org-make-wiktionary-link)
#+END_SRC

Above is the definition for my custom =org-make-wiktionary-link= function. Like
the description says, it creates a link to the Wiktionary entry on the selected
word (or, if no region is active, the word where the cursor is). Furthermore, I
have set it to always bring up the Russian definition, but if you copy this
function to your own configuration, you can just set =wiktionary-language= to
='english= or something, or even ='non-existent-language= if you don't want to look
up any specific language.
     
I have written it because I study Russian and write down all the words I
learn in an Org file. For more language-related settings, see the section
on [[#lang][non-English languages]].

*** Tangling my configuration

Because I keep my Emacs configuration in an Org document, I need a quick and
easy way to have =org-babel= /tangle/ my configuration to =config.el=, which is loaded
by Emacs at startup.

This Org document is full of code blocks that shouldn't be tangled. It's also
full of source blocks that /should/ be tangled, but not whenever I want to update
my configuration.

This is a problem, because there is no built-in function to tangle a source
block by name, for example. So I wrote the following function to automatically
do it for me.

Obviously, it's highly personalized and depends on there only being one code
block with the name =c:config-all=, so if you copy this function, you should
probably edit that.

#+NAME: c:org:fun
#+BEGIN_SRC emacs-lisp
(defun org-babel-tangle-config ()
  (interactive)

  (let ((tangle-buffer (clone-indirect-buffer "<tangle>config" nil :norecord)))
    (with-current-buffer tangle-buffer
      (widen)
      (goto-char (org-babel-find-named-block "c:config-all"))
      (let ((current-prefix-arg '(4)))
        (call-interactively #'org-babel-tangle)))
    (kill-buffer tangle-buffer))
  (byte-compile-file "config.el"))

(define-key org-mode-map (kbd "C-c C-v M-t") #'org-babel-tangle-config)
#+END_SRC

*** Adjusting /org-beginning-of-line/
:PROPERTIES:
:CUSTOM_ID: org-beginning-of-line
:END:

I know the following code will look hectic, but it's quite simple. You only need
to pay attention to a couple of lines. You see, this is the
=org-beginning-of-line= function, copied from the Org source, but modified to use
a function in my Emacs configuration called =smarter-beginning-of-line=, based on
the function with the same name [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][written by Bozhidar Batsov]] of Emacs Redux. For
my implementation of it, see the section on [[#beginning-end-of-line][making C-a smarter]]. In a nutshell,
it moves to indentation unless the point is already at indentation, in which
case it moves to the true beginning of line.

Let's have a look at the code and then I'll explain it.

#+NAME: c:org:fun
#+BEGIN_SRC emacs-lisp
(defun org-smarter-beginning-of-line (original-function &optional n)
  "The exact same function as `org-beginning-of-line',
but with one exception: instead of calling `beginning-of-line'
twice, it calls `smarter-beginning-of-line' once."
  (interactive "^p")
  (let ((origin (point))
        (special (pcase org-special-ctrl-a/e
                   (`(,C-a . ,_) C-a) (_ org-special-ctrl-a/e)))
        deactivate-mark)
    ;; First move to a visible line.
    (if (bound-and-true-p visual-line-mode)
        (beginning-of-visual-line n)
      (smarter-move-beginning-of-line n))
    (cond
     ;; No special behavior.  Point is already at the beginning of
     ;; a line, logical or visual.
     ((not special))
     ;; `beginning-of-visual-line' left point before logical beginning
     ;; of line: point is at the beginning of a visual line.  Bail
     ;; out.
     ((and (bound-and-true-p visual-line-mode) (not (bolp))))
     ((let ((case-fold-search nil)) (looking-at org-complex-heading-regexp))
      ;; At a headline, special position is before the title, but
      ;; after any TODO keyword or priority cookie.
      (let ((refpos (min (1+ (or (match-end 3) (match-end 2) (match-end 1)))
                         (line-end-position)))
            (bol (point)))
        (if (eq special 'reversed)
            (when (and (= origin bol) (eq last-command this-command))
              (goto-char refpos))
          (when (or (> origin refpos) (= origin bol))
            (goto-char refpos)))))
     ((and (looking-at org-list-full-item-re)
           (memq (org-element-type (save-match-data (org-element-at-point)))
                 '(item plain-list)))
      ;; Set special position at first white space character after
      ;; bullet, and check-box, if any.
      (let ((after-bullet
             (let ((box (match-end 3)))
               (cond ((not box) (match-end 1))
                     ((eq (char-after box) ?\s) (1+ box))
                     (t box)))))
        (if (eq special 'reversed)
            (when (and (= (point) origin) (eq last-command this-command))
              (goto-char after-bullet))
          (when (or (> origin after-bullet) (= (point) origin))
            (goto-char after-bullet)))))
     ;; No special context.  Point is already at beginning of line.
     (t nil))))

(advice-add 'org-beginning-of-line :around #'org-smarter-beginning-of-line)
#+END_SRC

So why all this code?

First of all, Org-mode has its own function for moving to the beginning of the
line, and if you set enable =org-special-ctrl-a/e=, it is really useful. For that
reason, I want to use Org's own function, but force it to use
=smarter-beginning-of-line= instead of =beginning-of-line=.

Now, this /should/ be as easy as just replacing the =beginning-of-line= function
with =smarter-beginning-of-line=, but unfortunately this doesn't work, because
=org-beginning-of-line= stupidly calls =beginning-of-line= /twice/!

This will not work with =smarter-beginning-of-line=, because calling that function
twice will always move the cursor to the actual beginning of line, and never it
will never move to the indentation, which sort of is the point of the entire
function.

The easiest way to solve the problem is, unfortunately, copying the
=org-beginning-of-line= function definition and modifying it to call
=move-beginning-of-line= only /once/. Or in my case, =smarter-beginning-of-line=,
once.

This works well, but of course it will block any potential future changes to
=org-beginning-of-line= by the Org developers. On the other hand, it's unlikely
that such a basic and well-working function should recieve any significant
updates.

** Racket
:PROPERTIES:
:CUSTOM_ID: racket-mode
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package racket-mode
  :bind (:map racket-repl-mode-map
              ("<f5>" . /racket-repl-run))
  :bind (:map racket-mode-map
              ("<S-f5>" . /racket-interrupt-run))
  :config
  (defun /racket-repl-run ()
    "From any buffer (usually the Racket REPL buffer), run the
    Racket program in the first buffer found whose name ends with
    \".rkt\"."
    (interactive)
    (let ((rkt-buffer (car (cl-remove-if-not
                            (lambda (buffer)
                              (string-suffix-p ".rkt" (buffer-name buffer)))
                            (buffer-list))))) ; assume first .rkt buffer
      (with-current-buffer rkt-buffer
        (racket-run))))
  (defun /racket-interrupt-run ()
    "Run the Racket program in the current buffer, after sending
    an interrupt signal to the Racket REPL (C-c)."
    (interactive)
    (with-current-buffer racket--repl-buffer-name
      (comint-interrupt-subjob))
    (racket-run))
  (add-hook 'racket-repl-mode-hook #'toggle-truncate-lines))
#+END_SRC

** LaTeX

#+BEGIN_SRC emacs-lisp
(use-package auctex
  :config
  (defun start-update-viewer ()
    "Starts/updates PDF viewer."
    (interactive)
    (if (string-match "no process found"
                      (shell-command-to-string "killall -HUP mupdf-x11"))
        (start-process-shell-command
         "mupdf"          ; process name
         "mupdf"          ; process buffer
         (concat "mupdf " ; shell command
                 (expand-file-name
                  (concat "output/"
                          (file-name-base (buffer-file-name))
                          ".pdf"))))))

  (defun save-run ()
    "Saves the document and processes it."
    (interactive)
    (save-buffer)
    (TeX-command-run-all nil))

  (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))

  :bind (:map LaTeX-mode-map
              ("C-c C-u" . start-update-viewer)))

#+END_SRC

** Python

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
;; python-mode
(defun shell-compile () ; (courtesy of djangoliv @ stack interchange)
  (interactive)
  (shell-command (concat "python " (buffer-file-name)))
  (if (<= (* 2 (window-height)) (frame-height))
      (enlarge-window 20)
    (/ (frame-height) 2)))
(add-hook 'python-mode-hook
          '(lambda ()
             (define-key python-mode-map (kbd "C-c C-c") 'shell-compile)))
#+END_SRC



* E-mail
:PROPERTIES:
:CUSTOM_ID: e-mail
:END:

Because I like living in Emacs, I like to read my e-mail in Emacs.

** Gnus

For my Gnus configuration, see the =gnus/gnus.el= file.

#+NAME: c:e-mail
#+BEGIN_SRC emacs-lisp
(defun gnus-dir (&optional path) (concat user-emacs-directory "gnus/" path))
(setf gnus-init-file (gnus-dir "gnus.el"))
#+END_SRC

** /notmuch/

*Note to self:* Should this configuration even be stored in this document?
Probably not. It is more suitable as part of a blog post. Now I just need to
start a blog ...


*** Personal /mail/ shell script

#+BEGIN_SRC sh :tangle ~/bin/mail :shebang #!/usr/bin/zsh
case $1 in
    pull)
        mbsync -a;
        echo "Press any key to continue...";
        read; # in case mbsync fails, give user chance to abort and try again
        notmuch new;
        afew --tag --new;;
    push)
        afew --move-mail --new;
        mbsync -a;;
    *)
        echo "Usage: mail {pull|push}";
        exit 1;;
esac
#+END_SRC

*** Refresh status message

#+NAME: c:e-mail
#+BEGIN_SRC emacs-lisp
(defvar notmuch-hello-refresh-count 0)

(defun notmuch-hello-refresh-status-message ()
  (let* ((new-count
          (string-to-number
           (car (process-lines notmuch-command "count"))))
         (diff-count (- new-count notmuch-hello-refresh-count)))
    (cond
      ((= notmuch-hello-refresh-count 0)
       (message "You have %s messages."
                (notmuch-hello-nice-number new-count)))
      ((> diff-count 0)
       (message "You have %s more messages since last refresh."
                (notmuch-hello-nice-number diff-count)))
      ((< diff-count 0)
       (message "You have %s fewer messages since last refresh."
                (notmuch-hello-nice-number (- diff-count)))))
    (setq notmuch-hello-refresh-count new-count)))

(add-hook 'notmuch-hello-refresh-hook 'notmuch-hello-refresh-status-message)
#+END_SRC

*** Helm completion

#+NAME: c:e-mail
#+BEGIN_SRC emacs-lisp
(setq notmuch-address-selection-function
      (lambda (prompt collection initial-input)
        (completing-read prompt (cons initial-input collection) nil t nil 'notmuch-address-history)))
#+END_SRC

This does not seem to work.


* Custom hooks
:PROPERTIES:
:CUSTOM_ID: custom-hooks
:END:

#+NAME: c:custom-hooks
#+BEGIN_SRC emacs-lisp
;; window-focus-out-hook, window-focus-in-hook

(defun run-window-focus-out-hook (window &optional norecord)
  (run-hooks 'window-focus-out-hook))
(defun run-window-focus-in-hook (window &optional norecord)
  (run-hooks 'window-focus-in-hook))

(advice-add 'select-window :before 'run-window-focus-out-hook)
(advice-add 'select-window :after 'run-window-focus-in-hook)

;; NOTE: This doesn't always play nice with magit. For example, select-window
;; seems to be run when opening the commit message buffer, but *not* when
;; returning to the magit status buffer. I'm not quite sure why, but I suppose I
;; could add an exception for it. I'd have to look at the magit source. Perhaps
;; I could just run a function upon switch-to-buffer that checks whether the
;; current-window is different from the previous-current-window (saved in a
;; variable); that might be the most simple solution, similar to what hl-line
;; does, but as I've said before, more efficient than attaching everything to
;; post-command-hook ...

;; TODO: Add exception for magit buffer switching.

;; before-minibuffer-hook, after-minibuffer-hook

(defun run-before-minibuffer-hook (&optional &rest args)
  (run-hooks 'before-minibuffer-hook)
  (add-hook 'post-command-hook 'run-after-minibuffer-hook))
(defun run-after-minibuffer-hook (&optional &rest args)
  (unless (minibufferp)
    (run-hooks 'after-minibuffer-hook)
    (remove-hook 'post-command-hook 'run-after-minibuffer-hook)))

(advice-add 'read-from-minibuffer :before 'run-before-minibuffer-hook)
(advice-add 'read-no-blanks-input :before 'run-before-minibuffer-hook)
(advice-add 'read-string          :before 'run-before-minibuffer-hook)

;; before-helm-hook, after-helm-hook

(defun run-before-helm-hook (&optional &rest args)
  (run-hooks 'before-helm-hook))
(defun run-after-helm-hook (&optional &rest args)
  (run-hooks 'after-helm-hook))

(add-hook 'helm-before-initialize-hook 'run-before-helm-hook)
(add-hook 'helm-exit-minibuffer-hook   'run-after-helm-hook)
(advice-add 'helm-keyboard-quit :after 'run-after-helm-hook)
#+END_SRC


* Visuals
:PROPERTIES:
:CUSTOM_ID: visuals
:END:

** Theme configuration

I like to be flexible when it comes to themes. For example, I want to be able to
switch themes in the middle of a session without any issues. I also want Emacs
to automatically load a sensible theme depending on the amount of daylight.
Furthermore, I want to be able to easily adjust the themes I use, because they
aren't perfect.

I believe I have succeeded in achieving my goals, and rather nicely at that.

*** Daylight-dependent default theme
:PROPERTIES:
:CUSTOM_ID: daylight-sets-color
:END:

This is a function that I have ported from my old =vimrc=. It relies on =sun=, a
highly personalized script of which I am /not/ particularly proud, because of how
ugly it is ... But if you absolutely /have/ to see it, it's available at [[https://github.com/jocap/uppsala-sun][GitHub]] -
you've been warned.

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(defun daylight-sets-color ()
  "Sets a light theme for day and a dark theme for night.
Depends on the script `sun' being found in path."
  (interactive)
  (let ((time (string-to-number (format-time-string "%H.%M"))))
        (if (string-match "not found" (shell-command-to-string "which sun"))
            (if (and (> time 6.00) (< time 18.00)) ; default if `sun' not found
                (load-theme light-theme t)
              (load-theme dark-theme t))
          (let ((sunrise
                 (string-to-number (shell-command-to-string "sun _rise")))
                (sunset
                 (string-to-number (shell-command-to-string "sun _set"))))
            (if (and (> time sunrise) (< time sunset))
                (load-theme light-theme t)
              (load-theme dark-theme t))))))
#+END_SRC

The function depends on the following variables being set:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(setq light-theme 'leuven
      dark-theme  'zenburn)
#+END_SRC

To set the default theme on startup, I use the following code:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'daylight-sets-color)
#+END_SRC

*** Dynamic theme settings
:PROPERTIES:
:CUSTOM_ID: dynamic-theme-settings
:END:

Another of my goals was being able to easily adjust the colors of individual
themes. While my solution may not be "simple," it is efficient and easy to use.

The way I have it set up is that every time a theme is loaded, a function called
=theme-do-all= is run:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(advice-add 'load-theme :after (lambda (theme &optional rest ...)
                                 (theme-do-all theme)))
#+END_SRC

The =theme-do-all= function contains a bunch of different settings: some for all
themes, some only for specific themes.

The more interesting aspect of the function, however, is the way it sets up
/dynamic colors/, dependent on the colors of the loaded theme. For example, I
don't set a custom =fci-rule-color= (that's /fill-column-indicator/) for every
theme. Instead, I base it on the background color of the loaded theme, making it
stick out just enough to be distinguishable. This way, I can load /any/ theme and
the =fci-rule-color= will automatically be set to a sensible color.

To achieve this, I use the =color= functions. I also define my own =intensify= and
=anti-intensify= functions, which depend on the lightness of the theme's
background.

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(defvar current-theme)

(defun theme-do-all (theme)
  "Actions to perform whenever a theme is loaded."

  (setf current-theme theme)

  (require 'color) ; for color-* functions

  (let* ((bg
          (alist-get 'background-mode (frame-parameters)))
         (intensify
          (if (eq bg 'dark) 'color-darken-name 'color-lighten-name))
         (anti-intensify
          (if (eq bg 'dark) 'color-lighten-name 'color-darken-name)))

    ;; Settings for all themes
    ;; ***********************

    ;; * Dynamic mouse pointer color
    (set-mouse-color
     (if (eq bg 'dark) "#ffffff" "#000000"))

    ;; * fci-rule-color -> desaturate, anti-intensity
    (setq fci-rule-color (color-desaturate-name
                          (funcall anti-intensify
                                   (face-attribute 'default :background) 15) 50))

    ;; * org-block-background -> desaturate, darken
    (set-face-attribute 'org-block nil
                        :background (color-desaturate-name
                                     (color-darken-name
                                      (face-attribute 'default :background) 3) 20)
                        :foreground (face-attribute 'default :foreground))

    ;; * org-block-begin-line, org-block-end-line
    (cl-loop
       for face in '(org-block-begin-line org-block-end-line)
       do (set-face-attribute
           face nil
           :background (color-desaturate-name
                        (color-darken-name
                         (face-attribute 'default :background) 15) 50)
           :foreground (color-desaturate-name
                        (funcall intensify
                                 (face-attribute 'default :foreground) 20) 90)
           :weight (face-attribute 'default :weight)
           :slant (face-attribute 'default :slant)))

    ;; * ivy-current-match -> remove underline and add background
    (when (eq (face-attribute 'ivy-current-match :underline) t)
      (set-face-attribute 'ivy-current-match nil :underline 'unspecified)
      (when (eq (face-attribute 'ivy-current-match :background) 'unspecified)
        (let* ((default-bg (face-attribute 'default :background))
               (bg-1       (funcall intensify default-bg 15))
               (bg-2       (funcall anti-intensify default-bg 15))
               ;; Ensure background isn't too dark or light:
               (final-bg   (if (if (eq bg 'dark)
                                   (> (color-distance bg-1 "#000000") 5000)
                                 (> (color-distance bg-1 "#FFFFFF") 5000))
                               bg-1
                             bg-2)))
          (set-face-attribute 'ivy-current-match nil :background final-bg))))

    ;; * fix italic faces
    ;; (mapc
    ;;  (lambda (face)
    ;;    (when (eq (face-attribute face :slant) 'italic)
    ;;      (set-face-attribute face nil :family "Fira Mono Medium")))
    ;;  (face-list))

    ;; * Reset fci-mode
    (let ((inhibit-message t))
      (call-interactively 'fci-mode)
      (call-interactively 'fci-mode))

    ;; Settings for specific themes
    ;; ****************************

    (cl-case theme
      ;; * Gruxbox
      ('gruvbox
       (custom-theme-set-faces
        'gruvbox ; fix hard-to-see org-mode colors
        '(org-verbatim ((t (:foreground "DarkGray"))))
        '(org-document-info-keyword ((t (:foreground "DarkGoldenrod"))))))

      ;; * Tango
      ('tango
       (custom-theme-set-faces
        'tango
        '(hl-line ((t (:background "#dddddd"))))))

      ;; * Tango-dark
      ('tango-dark
       (custom-theme-set-faces
        'tango-dark ; fix crazy hl-line (bright yellow per default!)
        '(hl-line ((t (:background "#444444")))))))

    ;; * Eziam
    (when (or (equal theme 'eziam-dark) (equal theme 'eziam-light))
      (custom-theme-set-faces
       theme
       ;; - Less contrastive cursor
       `(cursor ((t (:background
                     ,(funcall
                       anti-intensify
                       (face-attribute 'default :foreground) 25)))))
       ;; - More contrastive paren match
       `(show-paren-match ((t (:background
                               ,(funcall
                                 anti-intensify
                                 (face-attribute 'default :background) 25))))))
      ;; - Fading rainbow-delimiters (from black to light gray)
      (cl-loop for n in (number-sequence 1 9)
               do (let ((face-name (concat
                                    "rainbow-delimiters-depth-"
                                    (number-to-string n)
                                    "-face"))
                        (color (funcall
                                intensify
                                (face-attribute 'default :foreground)
                                (* n 6))))
                    (custom-theme-set-faces
                     theme
                     (list (intern face-name) `((t (:foreground ,color))))))))))

(defun theme-reload ()
  (interactive)
  (if (boundp 'current-theme)
      (theme-do-all current-theme)))

(global-set-key (kbd "C-c R") #'theme-reload)
#+END_SRC

It may look a bit busy, but that's because of the nature of setting face
attributes via Emacs Lisp.

Among some of the interesting settings are the custom =rainbow-delimiters= fading
from black to light gray - or from white to dark gray, if =eziam-dark= is loaded
instead of =eziam-light=.

*** Switching between themes
:PROPERTIES:
:CUSTOM_ID: theme-switching
:END:

To switch themes, I simply use =load-theme=. There is one problem with that,
though. Per default, =load-theme= doesn't unload the old theme. The following
code, surely copied from the internet, fixes that:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
;; - Disable previous theme when enabling new theme
(add-hook 'after-init-hook
          (lambda () (defadvice load-theme
                         (before theme-dont-propagate activate)
                       (mapc #'disable-theme custom-enabled-themes))))
#+END_SRC

** Fonts

#+BEGIN_SRC emacs-lisp
(defun /setup-fonts (&optional r)
  (let ((sans-serif-font (cl-case system-type
                           ('darwin    "Lucida Grande")
                           ('gnu/linux "Verdana"))))
    (when (eq system-type 'darwin)
      ;; Replace Sans Serif with Lucida Grande
      (mapc
       (lambda (face)
         (when (string-equal (face-attribute face :family) "Sans Serif")
           (set-face-attribute face nil :family sans-serif-font)))
       (face-list)))))

(advice-add #'theme-do-all :after #'/setup-fonts)
#+END_SRC


* Language configuration
:PROPERTIES:
:CUSTOM_ID: lang
:END:

** TODO Spelling
:PROPERTIES:
:CUSTOM_ID: spelling
:END:

# add NAME when done
#+BEGIN_SRC emacs-lisp
(require 'ispell)
(add-to-list 'ispell-dictionary-alist
             '("swedish-hunspell"
               "[[:alpha:]]"
               "[^[:alpha:]]"
               "[']"
               t
               ("-d" "sv_SE")
               nil
               utf-8))

(add-to-list 'ispell-dictionary-alist
             '("english-hunspell"
               "[[:alpha:]]"
               "[^[:alpha:]]"
               "[']"
               t
               ("-d" "en_US")
               nil
               utf-8))
(setq ispell-program-name "hunspell"
      ispell-dictionary   "swedish-hunspell")
#+END_SRC

** Swedish mode
:PROPERTIES:
:CUSTOM_ID: swe
:END:

#+NAME: c:lang:config
#+BEGIN_SRC emacs-lisp
;; Based on work by Moritz Ulrich <ulrich.moritz@googlemail.com>
;; Published under GNU General Public License

(defvar swedish-mode-map (make-keymap) "Swedish mode keymap.")

(define-key swedish-mode-map (kbd "s-[")  (lambda () (interactive) (insert ?√•)))
(define-key swedish-mode-map (kbd "s-'")  (lambda () (interactive) (insert ?√§)))
(define-key swedish-mode-map (kbd "s-;")  (lambda () (interactive) (insert ?√∂)))
(define-key swedish-mode-map (kbd "s-{")  (lambda () (interactive) (insert ?√Ö)))
(define-key swedish-mode-map (kbd "s-\"") (lambda () (interactive) (insert ?√Ñ)))
(define-key swedish-mode-map (kbd "s-:")  (lambda () (interactive) (insert ?√ñ)))

(define-minor-mode swedish-mode
  "A mode for conveniently using Swedish letters in Emacs."
  nil
  :lighter " √•√§√∂"
  swedish-mode-map)

(provide 'swedish-mode)
#+END_SRC

** Combining acute accent
:PROPERTIES:
:CUSTOM_ID: combining-acute-accent
:END:

#+NAME: c:lang:config
#+BEGIN_SRC emacs-lisp
;; Insert combining acute accent
(global-set-key (kbd "C-c 8 '") (lambda () (interactive) (insert-char 769)))
#+END_SRC


* Preventing repeated strain injury
:PROPERTIES:
:CUSTOM_ID: rsi
:END:


* Operating systems

** Windows Subsystem for Linux (WSL)
:PROPERTIES:
:CUSTOM_ID: wsl
:END:

I only own Windows PCs, with Windows installed on every single one, and I do
rely on Windows for a lot of things: PC games, Microsoft Word, the experience of
using a commercial and well-functioning operating system ... My only problem is
programming. I /cannot/ program on Windows. =cmd.exe=, as well as the newer
PowerShell, is unusable - not necessarily because they suck, but because I'm
very used to *nix systems.

/Bash on Ubuntu on Windows: Windows Subsystem for Linux/ (WSL for short) solves
that problem for me. It isn't perfect and everything doesn't work great. But
most things work really well - surprisingly well, even. I am as amazed as
impressed by the work done by the WSL team. My respect for Microsoft, as well as
the Windows' potential as a powerful development environment, is higher than
ever.

Using WSL does mean I have to do some things a bit differently, and adjust my
configuration accordingly. Most of this configuration happens in my Zsh
configuration files, but some of it inevitably leaks into my Emacs
configuration.

*** Launching Emacs
:PROPERTIES:
:CUSTOM_ID: launching-emacs
:END:

Using the graphical version of Emacs on WSL is a bit trickier than just the
plain old terminal verison, as you need an X server to run it. But as it turns
out, there are X servers for Windows! Personally, I use [[https://sourceforge.net/projects/vcxsrv/][VcXsrv]], because I've
heard it's good, but [[http://www.straightrunning.com/XmingNotes/][Xming]] seems to be a solid alternative.

I use VcXsrv in its "multiple windows" mode. This means that every X window will
behave like any other normal Windows window (that's a lot of "windows"). It will
have a Windows title bar and be fully integrated into the native window manager.

To launch Emacs without having to use a terminal, I actually use a program
part of the Xming project (but bundled separately) called =run.exe=. It provides a
way of launching X applications and disowning them, so you won't need to have a
terminal open in order to run your GUI programs.

I keep =run.exe= in my Windows =PATH=, and I have the following shortcut as an icon
on my desktop:

#+BEGIN_SRC
run.exe bash.exe -c "LAUNCH_AT_START='emacs' zsh"
#+END_SRC

Now, the code above could have been simpler if I just used bash. However, my
main shell is =zsh= and I'd like for Emacs to use that shell, along with my =zsh=
configuration, specifically so that I can access my custom-set =$PATH=.

The following code at the end of my =zsh= configuration makes it work:

#+BEGIN_SRC shell :tangle ~/.config/zsh/load/system/wsl/launch_at_start.zsh
local LAUNCH_PROGRAM=0
local LAUNCH_PROGRAM="$LAUNCH_AT_START"
export LAUNCH_AT_START=0 # prevent launched program to launch more programs

case "$LAUNCH_PROGRAM" in
    emacs)
        nohup emacs &> /dev/null & disown; exit;;
    gnome-terminal)
        nohup gnome-terminal &> /dev/null & disown; exit;;
    i3)
        nohup i3 &> /dev/null & disown; exit;;
esac
#+END_SRC

In the shell script I also have a launch option for =gnome-terminal=, which I like
to use instead of the default =bash.exe=.

*** Default programs
:PROPERTIES:
:CUSTOM_ID: wsl:default
:END:

I use WSL for most development tools - like Emacs, Zsh and the odd local web
server - but I use native Windows programs for things like music playing and
web browsing.

**** Web browser
:PROPERTIES:
:CUSTOM_ID: wsl:web-browser
:END:

***** Problem

My web browser of choice is Firefox, because of the extensibility and
reliability. Emacs can be configured to use Firefox by customizing
=browse-url-browser-function= and setting it to /Firefox/. This will make
Emacs attempt to launch Firefox when I click on a link.

Of course, I haven't got Firefox installed on my WSL system, but I symlinked
=~/bin/firefox= to the path of the Windows version of Firefox:

#+BEGIN_SRC sh :tangle no
ln -s /mnt/c/Program\ Files/Mozilla\ Firefox/firefox.exe ~/bin/firefox
#+END_SRC

For a while, this solution worked fine. However, not all modes respect the
=browse-url-browser-function= setting. org-mode tries to use
=sensible-browser=, which relies on the =BROWSER= variable. To make
=sensible-browser= use Firefox, I simply put the following in my Zsh
configuration:

#+BEGIN_SRC sh :tangle no
export BROWSER="firefox"
#+END_SRC

Still, when org-mode tries to open the HTML file it just exported, it seems
to run into some problem. A Firefox window opens, but it's empty, without
any URL in the address bar!

This happens when Emacs tries to open /any/ file in the web browser, simply
because =firefox.exe= won't recognize any Linux path. It needs a /Windows/
path.

***** Solution

To solve this once and for all, I scrapped my old symlinks and aliases and
instead, wrote the following shell script:

#+BEGIN_SRC sh :tangle ~/bin/wsl-browser :shebang #!/usr/bin/zsh
if [[ $1 =~ ^https?:// ]]; then
    local open_path="$1"
elif [[ $1 =~ ^/mnt/c ]]; then
    local linux_path="/mnt/c"
    local windows_path="file:///C:/"
    local open_path="${1/$linux_path/$windows_path}"
else
    local abs_path=$(readlink -f $1)
    local open_path="file:///C:/Users/JohnAJ/AppData/Local/lxss$abs_path"
fi

/mnt/c/Program\ Files/Mozilla\ Firefox/firefox.exe $open_path
#+END_SRC

The script treats any argument starting with =http://= or =https://= as normal URLs.
Any other path, it tries to convert to the equivalent Windows path.

At first, I didn't have the /elif/-clause, but I noticed that sometimes, Emacs
would try to open in the web browser a file that was on the Windows-side of the
filesystem - that is, with a path starting with =/mnt/c=.

Within the Linux system, =/mnt/c= is an access point to all files on the Windows
installation. Within the Windows system, =C:\Users\JohnAJ\AppData\Local\lxss= is
an access point to the Linux file system. But despite that,
=C:\Users\JohnAJ\AppData\Local\lxss\mnt\c= does /not/ resolve to =C:\=.

For this reason, I couldn't just tell =firefox.exe= to open
=file:///C:/Users/JohnAJ/AppData/Local/lxss/mnt/c/=. To Windows programs, it's an
empty directory. I therefore added a special case for all paths starting with
=/mnt/c=, redirecting straight to =file:///C:/=, which isn't an empty directory.

I saved the script as =~/bin/wsl-browser=, the =~/bin= directory being in my =$PATH=,
and gave myself permissions to run it:

#+BEGIN_SRC sh :tangle no
chmod +x ~/bin/wsl-browser
#+END_SRC

Additionally, I symlinked both =firefox= and =sensible-browser=
to the file. This way, any tool on my system that tries to use one of those
programs will use my script instead.

In Emacs, my default browser is =firefox=, so that it remains compatible
with other systems, where I don't use my =wsl-browser= script.


** Mac OS X
:PROPERTIES:
:CUSTOM_ID: osx
:END:

I very rarely use Mac OS X, but when I do, I like my Emacs configuration to
work - and nicely, at that!

*** Fonts

#+NAME: c:osx
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  ;; Fix selections
  (defalias 'x-selection-owner-p 'ns-selection-owner-p))
#+END_SRC


* Credits

#+NAME: c:config-all
#+BEGIN_SRC emacs-lisp :noweb yes :tangle "config.el" :exports none
;; First & foremost
;; =============================================================================

<<c:first-and-foremost>>

;; Packages
;; =============================================================================

<<c:pkg:management>>
<<c:pkg:config>>

;; Basic preferences
;; =============================================================================

<<c:basic-prefs>>

;; Keybindings
;; =============================================================================

<<c:keybindings>>

;; Themes
;; =============================================================================

<<c:theme:config>>

;; E-mail
;; =============================================================================

<<c:e-mail>>

;; Language configuration
;; =============================================================================

<<c:lang:config>>

;; Custom hooks
;; =============================================================================

<<c:custom-hooks>>

;; Operating systems
;; =============================================================================

<<c:osx>>

;; Lastly
;; =============================================================================

(load custom-file)
#+END_SRC
