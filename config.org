#+TITLE: My Emacs Configuration
#+AUTHOR: John Ankarstr√∂m
#+LANGUAGE: en
#+OPTIONS: H:4 num:2 ':t todo:nil
#+PROPERTY: header-args :tangle no :results value silent

#+HTML_HEAD: <link href="https://fonts.googleapis.com/css?family=Playfair+Display" rel="stylesheet" />
#+HTML_HEAD: <link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" />
#+HTML_HEAD: <link rel="stylesheet" href="file:///C:/Users/JohnAJ/AppData/Local/lxss/home/john/.config/emacs/config.css" type="text/css" />
  
* Introduction

Welcome to my Emacs configuration. It is written in the style of literate
programming, which means, in this case, that it's written in Org-mode. Perhaps
unlike other Emacs configurations written in Org, however, it is written in a
non-linear fashion. That means that source code is presented in a way that's
suitable for the /documenting/ of code, and not the running of code. If you
copied all source blocks in this document and put them in the same order in an
Emacs configuration file, it might not work. If you want to see exactly how
the resulting code is arranged, you can look at the resulting [[https://github.com/jocap/emacs.d/blob/master/config.el][=config.el= file
on GitHub]].


* Packages

** Package management

First and foremost, I define what sources to install packages from:

#+NAME: c:pkg:management
#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives
      '(("gnu" . "http://elpa.gnu.org/packages/")
        ("org" . "http://orgmode.org/elpa/")
        ("melpa" . "http://melpa.org/packages/")
        ("melpa-stable" . "http://stable.melpa.org/packages/")))
(setq package-archive-priorities
      '(("melpa-stable" . 1)))
(package-initialize)
#+END_SRC

I call =package-initialize= here, because I want all installed packages to be
loaded automatically with their default configuration, /except/ the ones I
explicitly configure with =use-package=.

For that I initialize /use-package/:

#+NAME: c:pkg:management
#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
(require 'diminish) ; if you use :diminish
(require 'bind-key) ; if you use any :bind variant
#+END_SRC

** List of packages

As I've said, this document is presented in a non-linear way. Under this rubric,
I list all the packages that I have installed and that I use. However, their
respective configurations are listed elsewhere.

*** Packages with configuration elsewhere

- [[#multiple-cursors][multiple-cursors]]
- [[#visual-regexp][visual-regexp]]
- [[#expand-region][expand-region]]
- [[#paredit][paredit]]
- [[#iy-go-to-char][iy-go-to-char]]
- [[#avy][avy]]
- [[#origami][origami]]
- [[#helm][helm]]
- [[#projectile][projectile]]
- [[#magit][magit]]
- [[#git-gutter][git-gutter+]]
- [[#openwith][openwith]]
- [[#org-mode][org-mode]]

*** Packages without interesting configuration

In order to do their job, some packages have to be explicitly enabled in the
Emacs configuration, but do not need to be further configured. For that reason,
I probably won't mention these packages elsewhere, and instead just list them
here with a short description of why I like them.

- rainbow-delimiters :: paints matching parentheses with the same color.

- ace-link :: nice little extension to /avy/ that does the same thing, but for
              links in help buffers.

- nlinum :: line numbers, but faster than =linum=. I don't use this much, but it's
            nice to have when you need it.

- popwin :: makes popup windows /so/ much easier to work with - this is a
            must-have.

- helm-org-rifle :: makes it /a bit/ easier to browse through Org documents - not
                    perfect though.

- buffer-move :: lets me switch buffers between two windows - pretty handy.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp :exports none
(use-package rainbow-delimiters
  :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

(use-package ace-link
  :ensure avy
  :config
  (ace-link-setup-default))

(use-package nlinum
  :bind (("C-c l" . nlinum-mode)))

(use-package popwin
  :init
  (require 'popwin)
  (popwin-mode 1))

(use-package helm-org-rifle
  :bind (("C-c f" . helm-org-rifle-current-buffer)
         ("C-c F" . helm-org-rifle)))

(use-package buffer-move
  :init
  :bind (("C-c <up>"    . buf-move-up)
         ("C-c <down>"  . buf-move-down)
         ("C-c <left>"  . buf-move-left)
         ("C-c <right>" . buf-move-right)))

#+END_SRC


* Basic preferences
:PROPERTIES:
:CUSTOM_ID: basic-preferences
:END:

In my configuration, there are some basic settings that don't really belong
under any section in this documentation. Most of them are set using the
/Customize/ interface, but here are the ones that aren't:

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(server-start)         ; use emacs as a server
(electric-pair-mode 1) ; auto-insert matching pairs
(menu-bar-mode -1)     ; disable menu bar
(tool-bar-mode -1)     ; disable gui toolbar
(save-place-mode 1)    ; save cursor position
(xterm-mouse-mode t)   ; use mouse (somewhat effectively) in terminal

;; Activate auto-fill-mode for all text buffers
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

** Directories
:PROPERTIES:
:CUSTOM_ID: directories
:END:

Per default, Emacs insists on making a mess inside =~/.emacs.d=. These settings
prevent that.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))

(setq emacs-state-directory (expand-file-name "state/" user-emacs-directory))
(defun state-dir (file)
  (concat emacs-state-directory file))

;; - Various places

(setq auto-save-list-file-prefix (state-dir "auto-save-list/.saves~"))
(setq save-place-file (state-dir "save-place"))
(setq recentf-save-file (state-dir "recentf"))
(setq ido-save-directory-list-file (state-dir "ido.last"))
(setq eshell-directory-name (state-dir "eshell"))
(setq backup-directory-alist
      `((".*" . ,(state-dir "saves"))))

;; - Tramp
(setq tramp-backup-directory-alist backup-directory-alist)
(setq tramp-auto-save-directory (state-dir
                                        "tramp/auto-save/"))
(setq tramp-persistency-file-name (state-dir
                                          "tramp/persistency.el"))

;; - Projectile
(setq projectile-cache-file (concat emacs-state-directory
                                    "projectile/cache.el"))
(setq projectile-known-projects-file
      (concat emacs-state-directory
              "projectile/known-projects.el"))

;; - File for activated disabled commands
(defadvice en/disable-command (around put-in-custom-file activate)
  "Put declarations in `custom-file'."
  (let ((user-init-file (concat user-emacs-directory ".commands")))
    ad-do-it))
(load-file (concat user-emacs-directory ".commands"))
#+END_SRC

** Keybindings
:PROPERTIES:
:CUSTOM_ID: keybindings
:END:

Here are a couple of keybindings that don't really fit in under any other
headline. Most of them are based on built-in functions.

#+NAME: c:keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-<f1>") 'menu-bar-mode)

(global-set-key (kbd "M-]") 'other-window)
(global-set-key (kbd "M-[") (lambda (n) (interactive "p")
                                  (other-window (* -1 n))))

(global-set-key (kbd "M-n") (lambda (n) (interactive "p") (scroll-up n)))
(global-set-key (kbd "M-p") (lambda (n) (interactive "p") (scroll-down n)))
#+END_SRC

** Session management
:PROPERTIES:
:CUSTOM_ID: session-management
:END:

If there is a way to save the current window configuration to a file, and I mean
/only/ the window configuration (and, of course, the buffers that are open in
those windows), *please tell me*.

For the moment, I use =desktop-save-mode=, but I'm unhappy. It saves far too many
irrelevant things, like the theme I'm using and all buffers. I only want to
save the currently visible buffers and the positions of their windows. That's
it.

In the meantime, this is my configuration for =desktop-save-mode=.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(setq desktop-dirname             (concat emacs-state-directory "desktop/")
      desktop-base-file-name      "emacs.desktop"
      desktop-base-lock-name      "lock"
      desktop-path                (list desktop-dirname)
      desktop-save                t)
#+END_SRC

Furthrmore, I have a custom function that lets me easily activate the mode:

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun init-desktop (&optional arg)
  "Load the desktop (if C-u is provided) and enable autosaving."

  (interactive "p")
  (if current-prefix-arg (desktop-read))
  (desktop-save-mode 1)
  (message "Desktop-Save mode enabled"))

(global-set-key (kbd "C-c D") 'init-desktop)
#+END_SRC

** Shebang mode detection

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
;; Shebang mode detection
(add-to-list 'interpreter-mode-alist
             '("python3" . python-mode))
#+END_SRC


* Text editing

** Multiple cursors
:PROPERTIES:
:CUSTOM_ID: multiple-cursors
:END:

=multiple-cursors= is another indispensible part of my Emacs toolchain. This is
mostly a configuration of keys, but I also add =iy-go-to-char-start-pos= to the
=mc/cursor-specific-vars= list. This was recommended to me. The cursor specific
variables are, according to the =multiple-cursors= source, "a list of vars that
need to be tracked on a per-cursor basis."

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (("C-c c" . mc/edit-lines)
         ("C-c >" . mc/mark-next-like-this)
         ("C-c <" . mc/mark-previous-like-this)
         ("C-c ?" . mc/mark-all-like-this))
  :config (add-to-list 'mc/cursor-specific-vars 'iy-go-to-char-start-pos))
#+END_SRC

For a good and easy-to-reproduce example of how powerful =multiple-cursors=
really is, go to the buffer list (~M-x~ =list-buffers=). Let's say you have
multiple Magit buffers open that you want to kill.

Search your way to the first Magit buffer, highlight the =*magit-= prefix,
and run =mc/mark-all-like-this=. Now you have a cursor on every Magit
buffer in the list. Now you can type ~k~ to mark every buffer with a cursor
on it for deletion. After disabling your multiple cursors with ~C-g~, you
can finally press ~x~ to make the buffer menu execute your instructions and
delete all Magit buffers.

Of course, this particular task is more easily done using a function like
=kill-matching-buffers= or even the Helm buffers list, but the routine
described above clearly illustrates the power of having multiple cursors.

** Search & replace: /visual-regexp/
:PROPERTIES:
:CUSTOM_ID: visual-regexp
:END:

*visual-regexp* is certainly worth a spot on the "interesting" packages list, not
only because its configuration is special, but because it is /just so good/. Not
only does it provide an incremental regex replace function - that means live
preview (!) - but the extension *visual-regexp-steroids* lets you search and
replace using PCRE instead of Emacs syntax (!).

To get this working with =use-package=, I first configure the plain old
/visual-regexp/ package, but tell =use-package= to /defer/ its loading - you see, for
/visual-regexp-steroids/ to work, it seems as though it needs to load
/visual-regexp/ itself. If you load it beforehand, it won't work.

Because =use-package= enables lazy-loading of packages when their configuration
includes a =:bind= option, we have to explicitly tell it to load
/visual-regexp-steroids/ immediately, regardless of the /:bind/-clause. This, again,
so that /visual-regexp/ won't load before its muscly brother.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :defer) ; prevent loading this package before visual-regexp-steroids!

(use-package visual-regexp-steroids
  :ensure pcre2el ; much faster than Python
  :demand ; load this package immediately, regardless of :bind
  :bind (("C-c r" . vr/replace)
         ("C-c q" . vr/query-replace)
         ("C-c m" . vr/mc-mark)
         ("C-M-r" . vr/isearch-backward)
         ("C-M-s" . vr/isearch-forward))
  :config (setq vr/engine 'pcre2el))
#+END_SRC

I got this solution from [[https://github.com/benma/visual-regexp-steroids.el/issues/16#issue-123951566][a workaround]] posted by GitHub user /alamaison/.
Thank you!

To enable PCRE style regex, instead of the default Python style, I configure the
package to use /pcre2el/ as its engine.

An interesting function provided by /visual-regexp/ is =vr/mc-mark=. This
function integrates with the /multiple-cursors/ package to add a cursor to
every match to a regex search. Useful!

** Alignment
:PROPERTIES:
:CUSTOM_ID: alignment
:END:

*** Aligning comments

What follows is a function [[http://stackoverflow.com/a/20278032/305047][written by the user phils]] at StackOverflow. It is a
language-agnostic method of aligning comments. How useful!

#+NAME: basic-prefs
#+BEGIN_SRC emacs-lisp
(defun align-comments-in-region (beginning end)
  "Align comments within marked region."
  (interactive "*r")
  (let (indent-tabs-mode align-to-tab-stop)
    (align-regexp beginning end (concat "\\(\\s-*\\)"
                                        (regexp-quote comment-start)))))

(global-set-key (kbd "C-c M-a") #'align-comments-in-region)
#+END_SRC

** Working with Lisp
:PROPERTIES:
:CUSTOM_ID: lisp
:END:

*** Paredit
:PROPERTIES:
:CUSTOM_ID: paredit
:END:

Paredit is a totally indispensible tool for editing Lisp code. It changes the
way you write Lisp, by replacing many built-in editing commands as well as
providing its own set of functions, for creating, re-arranging, splitting,
convoluting and deleting s-expressions.

My only problem with Paredit is that it replaces ~M-r~. I frequently use ~M-r~ to
quickly move the cursor around the screen, but Paredit overrides that keybinding
with =paredit-raise-sexp=. To fix this, as you can see below, I have created a new
keybinding, ~M-R~, and put it inside a =use-package= /:bind/-clause. This way, as long
as I have Paredit installed, =use-package= binds ~M-R~ to the original function of
~M-r~.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package paredit
  :init
  (autoload 'enable-paredit-mode
    "paredit" "Turn on pseudo-structural editing of Lisp code." t)
  (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook           #'enable-paredit-mode)

  :config
  (defun paredit-delete-indentation (&optional arg)
    "Handle joining lines that end in a comment."
    (interactive "*P")
    (let (comt)
      (save-excursion
        (move-beginning-of-line (if arg 1 0))
        (when (skip-syntax-forward "^<" (point-at-eol))
          (setq comt (delete-and-extract-region (point) (point-at-eol)))))
      (delete-indentation arg)
      (when comt
        (save-excursion
      	  (move-end-of-line 1)
          (unless (s-blank-str? comt) (insert " "))
          (insert comt)))))

  (define-key paredit-mode-map (kbd "M-q") nil)

  :bind (("M-R" . move-to-window-line-top-bottom)
         ("M-^" . paredit-delete-indentation)
         ("M-Q" . paredit-reindent-defun)))
#+END_SRC

A nice related package is =paredit-everywhere=. It provides the a subset of the
Paredit functionality for languages that aren't Lisp. I personally configure it
to be activated in all programming modes:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package paredit-everywhere
  :ensure paredit
  :config (add-hook 'prog-mode-hook 'paredit-everywhere-mode))
#+END_SRC

** Working with regions
:PROPERTIES:
:CUSTOM_ID: regions
:END:

*** /expand-region/
:PROPERTIES:
:CUSTOM_ID: expand-region
:END:

I spend a lot of space setting up the shortcuts for =expand-region=, because
it is very useful. The functions speak for themselves. I use many of them, as
I find =er/expand-region= to work somewhat poorly with Emacs Lisp - perhaps
Paredit interferes with it.

In my configuration, I use ~C-'~ as a prefix for all =expand-region=
keybindings, and /Shift/ as a modifier to mark outside instead of inside the
region.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind (("C-' r"  . er/expand-region)
         ("C-' w"  . er/mark-word)
         ("C-' '"  . er/mark-inside-quotes)
         ("C-' \"" . er/mark-outside-quotes)
         ("C-' p"  . er/mark-inside-pairs)
         ("C-' P"  . er/mark-outside-pairs)
         ("C-' c"  . er/mark-comment)
         ("C-' t"  . er/mark-inner-tag)
         ("C-' T"  . er/mark-outer-tag)
         ("C-' f"  . er/mark-defun)))
#+END_SRC

*** /wrap-region/
:PROPERTIES:
:CUSTOM_ID: wrap-region
:END:

=wrap-region= is a handy plugin that automatically surrounds your selection with the
corresponding pairs when typing "paired" characters, like ~'~, ~"~ and ~(~.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp :exports none
(use-package wrap-region
  :config (wrap-region-mode t))
#+END_SRC

** Opening line below and above
:PROPERTIES:
:CUSTOM_ID: smart-open-line
:END:

Every Vim user knows how useful the =o= and =O= commands are. =smart-open-line= and
=smart-open-line-above= are two functions, borrowed from Emacs Redux, that emulate
this behavior.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun smart-open-line () ; (courtesy of Emacs Redux)
  "Insert an empty line after the current line.
  Position the cursor at beginning, according to current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))
(defun smart-open-line-above ()
  "Insert an empty line above the current line.
  Position the cursor at beginning, according to current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))
#+END_SRC

Personally, I use the following keybindings:

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-o") 'smart-open-line)
(global-set-key (kbd "M-O") 'smart-open-line-above)
#+END_SRC

Note, however, that if you use Emacs in a terminal, ~M-O~ will not work.

** Commenting lines
:PROPERTIES:
:CUSTOM_ID: commenting-lines
:END:

What follows is a function by Jason Viers at StackExchange. It makes it a bit
easier to comment either the current line or the current region.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun comment-dwim-line (&optional arg) ; (courtesy of Jason Viers @ SE)
  "Replacement for the comment-dwim command.
  If no region is selected and current line is not blank and we
  are not at the end of the line, then comment current line.
  Replaces default behaviour of comment-dwim, when it inserts
  comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position)
                                   (line-end-position))
    (comment-dwim arg)))

(global-set-key (kbd "C-;") 'comment-dwim-line)
#+END_SRC


* Movement

** Quickly jumping around
:PROPERTIES:
:CUSTOM_ID: jumping
:END:

Moving around using ~C-n~, ~C-p~, ~C-f~ and ~C-b~ is not only tiresome, but
probably quite [[#rsi][unergonomical]] as well. Under this section, I tell you about the
methods I use to quickly jump to any position in the current window.

*** /iy-go-to-char/
:PROPERTIES:
:CUSTOM_ID: iy-go-to-char
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package iy-go-to-char
  :bind (("M-m" . iy-go-to-char)
         ("M-M" . iy-go-to-char-backward)
         ("C-." . iy-go-to-char-continue)
         ("C-," . iy-go-to-char-continue-backward)))
#+END_SRC

*iy-go-to-char* is a simple tool that provides functionality like Vim's =f=
and =F=. Works well, without any problems.

*** /avy/
:PROPERTIES:
:CUSTOM_ID: avy
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package avy
  :commands avy-isearch
  :init (global-set-key (kbd "M-'") nil) ; reset M-'
  :config (define-key isearch-mode-map (kbd "M-'") 'avy-isearch)
  :bind (("C-M-'"   . abbrev-prefix-mark) ; re-bind default M-'
         ("M-' M-'" . avy-goto-line)
         ("M-' '"   . avy-goto-char)
         ("M-' s"   . avy-goto-char-timer)
         ("M-' w"   . avy-goto-word-1)))
#+END_SRC

*avy* is the successor to /ace-jump-mode/. It lets you jump to things
visually, but using the keyboa-rd. Smart man who came up with the original
idea.

For /avy/ I have dedicated the ~M-'~ keybinding. The default function tied
to ~M-'~ I have remapped to ~C-M-'~.

** Moving between windows: /windmove/
:PROPERTIES:
:CUSTOM_ID: windmove
:END:

For the most part, especially when using Org-mode, I use the normal ~C-x o~ to
switch between windows, but sometimes when you have multiple windows open, it's
easier just to use =windmove=. It is a package that provides simple directional
movement between windows.

Personally, I use the default keybindings, which make use of /Shift/ in
combination with any of the arrow keys.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package windmove
  :init (windmove-default-keybindings))
#+END_SRC

** Improving /move-beginning-of-line/
:PROPERTIES:
:CUSTOM_ID: c-a
:END:

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(defun smarter-move-beginning-of-line (&optional &rest args)
  "Move point back to indentation of beginning of line.
  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character
  and the beginning of the line.
  If ARG is not nil or 1, move forward ARG - 1 lines first. If
  point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (let ((arg (or (prefix-numeric-value current-prefix-arg) 1)))
    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))
    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-to-column 0))))) ; based on function from Emacs Redux
#+END_SRC

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(global-set-key [remap move-beginning-of-line]
                'smarter-move-beginning-of-line)
#+END_SRC


* Visual aids

** Folding with /origami/
:PROPERTIES:
:CUSTOM_ID: origami
:END:

Origami is a package that provides Vim-like folding. I have been an avid
Vim user, so folding is a natural part of my programming life.

The configuration that follows is /long/. I will therefore stop every now
and then, take a pause and explain what I've done:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package origami
  :config
  (global-origami-mode t)
  (setq-local origami-fold-style 'triple-braces)

  ;; I start the /:config/-clause by enabling =origami-mode= globally, and
  ;; setting the fold method to triple braces (that is, ={{{= and =}}}=).

  (defun origami-toggle-node () ; (courtesy of /u/Eldrik @ reddit)
    (interactive)
    (save-excursion ; leave point where it is
      (goto-char (point-at-eol)) ; then go to the end of line
      (origami-toggle-node (current-buffer) (point)))) ; and try to fold

  ;; The above function is borrowed from Reddit user /Eldrik/. I'm not sure what
  ;; it does better than just using =origami-toggle-node= directly, but it must be
  ;; doing something.

  (defun traverse-folds (times &optional beginning)
    "Traverses through folds as many times as ordered by argument.
    A negative argument makes it traverse backwards."

    (unless beginning (setq beginning (point)))
    (if (> times 0)
        (progn
          (move-end-of-line nil)
          (fset 'fun 'origami-forward-fold))
      (progn
        (move-beginning-of-line nil)
        (fset 'fun 'origami-previous-fold)))
    (dotimes (i (abs times))
      (condition-case err
          (fun (current-buffer) (point))
        (error (message "Fold not found: %s" err))))
    (set-mark beginning)
    (deactivate-mark))

  (defun next-fold (times)
    "Jumps to the beginning of the next fold (or previous, on
    negative argument)."

    (interactive "P")
    (unless times (setq times 1))
    (traverse-folds times))

  (defun previous-fold (times)
    "Jumps to the beginning of the previous fold, as many times as
    ordered by argument."

    (interactive "P")
    (unless times (setq times 1))
    (next-fold (* times -1)))

  (defun goto-fold (number)
    "Jumps to fold # (provided by argument) in file."

    (interactive "P")
    (unless number (setq number
                         (string-to-number (read-string "Jump to fold: "))))
    (setq beginning (point))
    (if (equal number 0) (setq number 1))
    (if (> number 0)
        (goto-char (point-min))
      (goto-char (point-max)))
    (traverse-folds number beginning))

  ;; Above are listed my own functions for traversing folds. I have functions
  ;; for going to the next, previous and nth fold, but they're all based on one
  ;; =traverse-folds= function. The reason I wrote my own function was that the
  ;; functions built into /origami/ didn't exactly work the way I wanted. They
  ;; would jump from fold end to fold end when jumping forwards - very annoying.

  :bind (("M-Z"     . custom-origami-toggle-node)
         ("C-M-z"   . origami-toggle-all-nodes)
         ("C-c C-z" . goto-fold)
         ("C-c C-n" . next-fold)
         ("C-c C-p" . previous-fold)))
#+END_SRC

Finally, some simple keybidnings, including ones for normal Origami
functions as well as for the above-defined custom functions.

In summary, it's a shame that this much configuration is needed to get such
a simple feature like folding working, especially when Vim supports it
almost perfectly from scratch. Overall, folding just doesn't seem to work
reliably in Emacs outside of Org-mode.

** Highlighting superfluous whitespace
:PROPERTIES:
:CUSTOM_ID: show-trailing-whitespace
:END:

With the following code, I enable highlighting of trailing whitespace in any
buffer whose mode descends from /prog-mode/.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda ()
                            (setq-local show-trailing-whitespace t)))
#+END_SRC

** Dynamic cursor shape
:PROPERTIES:
:CUSTOM_ID: dynamic-cursor-shape
:END:

One of the things I struggle with while using Emacs is identifying which window
is currently active. Highlighting the mode line helps, but it's usually not
enough for me. Previously, I have used =hl-line= with success, but I found that
the package was quite unoptimized and that it didn't play nice with some modes.

One of the solutions I have found is setting the cursor shape differently for
focused and unfocused windows.

I define the following functions to change the cursor shape to a hollow block
when a window becomes unfocused, and back to the default shape (that is, the
current cursor type when Emacs ran my configuration) when a window becomes
focused.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(setq default-cursor-type cursor-type)

(defun cursor-focused ()
  (setq-local cursor-type default-cursor-type))
(defun cursor-unfocused ()
  (setq-local cursor-type 'block))
#+END_SRC

The =cursor-unfocused= function is added to a couple of my custom hooks. For the
more important =cursor-focused=, I found myself forced to use =post-command-hook=,
even though I know it's overkill. It is surprisingly difficult to have Emacs
run a function whenever the window is changed.

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(add-hook 'post-command-hook 'cursor-focused)
;; Using post-command-hook because setting the cursor type is such a simple
;; action, and because select-window is called surprisingly often and often
;; without the suitable `norecord' argument ...

(add-hook 'window-focus-out-hook  'cursor-unfocused)
(add-hook 'before-minibuffer-hook 'cursor-unfocused)
(add-hook 'before-helm-hook       'cursor-unfocused)
#+END_SRC


* Helpful tools

** Helm
:PROPERTIES:
:CUSTOM_ID: helm
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package helm
  :commands helm-command-prefix
  :bind (("M-x"     . helm-M-x)
         ("C-x C-f" . helm-find-files)
         ("C-x C-b" . helm-mini))
  :init
  (global-set-key (kbd "C-c C-h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))
  (require 'helm-config)
  (helm-mode 1)
  :config
  (helm-autoresize-mode 1)
  (setq helm-mode-fuzzy-match t
        helm-completion-in-region-fuzzy-match t ; "fuzzy" matching
        helm-split-window-in-side-p           t ; helm inside current window
        helm-autoresize-max-height           40
        helm-autoresize-min-height           0))
#+END_SRC

I always feel a bit guilty when I use Helm. Which is, like, all the time,
because of how useful it is. I know it's big, a lot bigger than
alternatives like Ivy, and to be honest, some day I might try another
option, but for now, Helm does its job very well.

Apart from what I think are some pretty nice
keybindings, I configure Helm to do "fuzzy" matching, only display its
window below the current window and keep itself to a reasonable height.

** Projectile
:PROPERTIES:
:CUSTOM_ID: projectile
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure helm-projectile
  :config
  (projectile-global-mode)
  (setq projectile-enable-caching t)
  (setq projectile-require-project-root nil)

  (setq projectile-globally-ignored-directories
        (cl-list* ".cache" ".cargo"
                  projectile-globally-ignored-directories))

  (setq projectile-completion-system 'helm)
  (setq projectile-switch-project-action 'helm-projectile) ;; see http://tuhdo.github.io/helm-projectile.html#sec-5
  (helm-projectile-on))
#+END_SRC

Projectile is a package that I use for two reasons: the Helm integration
and the file finder.

** Magit
:PROPERTIES:
:CUSTOM_ID: magit
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind ("C-c g"   . magit-status))
#+END_SRC

The fact that *magit* requires this little configuration, yet is so
incredibly useful, is a testament to good design. The only thing I could
possibly complain about is the speed. It does run slow on my computer. I
hope it's just because I'm running it on the Windows Subsystem for Linux.

** /git-gutter+/
:PROPERTIES:
:CUSTOM_ID: git-gutter
:END:

As much as I love Magit, it's big, unwieldy and a bit slow. When editing my
Emacs configuration, I find that I postpone staging and commiting my changes,
lating having to do it all at once. It's annoying.

=git-gutter+= is an excellent package that lets me stage individual hunks of
changes without even leaving the buffer of the edited file. It works by
displaying plus and minus signs left of the fringe, indicating what lines have
been changed.

Just because it is so useful, I dedicate the prefix ~C-M-g~ to all =git-gutter+=
commands.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package git-gutter+
  :bind (("C-M-g C-M-g" . git-gutter+-mode))
  :bind (:map git-gutter+-mode-map
              ("C-M-g n" . git-gutter+-next-hunk)
              ("C-M-g p" . git-gutter+-previous-hunk)
              ("C-M-g d" . git-gutter+-show-hunk)
              ("C-M-g r" . git-gutter+-revert-hunks)
              ("C-M-g s" . git-gutter+-stage-hunks)
              ("C-M-g c" . git-gutter+-commit)))
#+END_SRC

The only problem I have with the package is that it doesn't use the actual
fringe. I have tried the extension =git-gutter+-fringe=, but I never got it to
work. Perhaps it needs updating, I don't know. For now, =git-gutter+= works fine.
** /openwith/
:PROPERTIES:
:CUSTOM_ID: openwith
:END:

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package openwith
  :init
  (openwith-mode t)
  (setq openwith-associations '(("\\.pdf\\'" "mupdf" (file)))))
#+END_SRC

*openwith* is a nice little plugin that does one thing very well. It tells Emacs
to open certain files in external programs. I personally use /mupdf/ for all my
PDF reading.


* Modes

** Org-mode
:PROPERTIES:
:CUSTOM_ID: org-mode
:END:

Org-mode is where I spend much of my Emacs time. I use it for writing, studying,
planning and, of course, configuring Emacs. My configuration began small but
as I've begun to use it more it has just kept growing.

This is the main configuration. You'll see a few references to custom =org-=
functions - they are defined further down.

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp
(use-package org
  :mode (("\\.org$" . org-mode))
  :ensure org-plus-contrib
  :demand
  :config
  ;; Make ' and " work in inline code
  (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\r\n,")
  (org-set-emph-re 'org-emphasis-regexp-components
                   org-emphasis-regexp-components) ; reload setting

  ;; Make windmove work in org-mode (not very useful)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)

  ;; Remove keybindings that I already use
  (define-key org-mode-map (kbd "C-'") nil)

  ;; Enable for all Org files
  (add-hook 'org-mode-hook #'swedish-mode) ; Swedish letters
  (add-hook 'org-mode-hook #'org-autolist-mode) ; better list behavior

  :bind (("C-c o a" . org-agenda)
         ("C-c o l" . org-store-link)
         ("C-c o c" . org-capture)
         ("C-c o b" . org-iswitchb)))
#+END_SRC

#+NAME: c:pkg:config
#+BEGIN_SRC emacs-lisp :noweb yes :exports none
(with-eval-after-load 'org
  <<c:org:fun>>
)
#+END_SRC

*** Automatic Wiktionary links
:PROPERTIES:
:CUSTOM_ID: org-make-wiktionary-link
:END:

#+NAME: c:org:fun
#+BEGIN_SRC emacs-lisp
(defun org-make-wiktionary-link (string &optional from to)
  "Wraps the word at point or selected word in a Wiktionary link to the word."

  ;; (see http://ergoemacs.org/emacs/elisp_command_working_on_string_or_region.html)
  (interactive
   (if (use-region-p)
       (list nil (region-beginning) (region-end))
     (let ((bds (bounds-of-thing-at-point 'word)) )
       (list nil (car bds) (cdr bds)))))

  (setq wiktionary-language 'russian)

  (let* ((input  (or string (buffer-substring-no-properties from to)))
         (output (concat "[[https://en.wiktionary.org/wiki/"
                         (org-link-escape (downcase input))
                         "#"
                         (capitalize (symbol-name wiktionary-language))
                         "]["
                         input
                         "]]")))
    (delete-region from to)
    (goto-char from)
    (insert output)))

(define-key org-mode-map (kbd "C-c L") #'org-make-wiktionary-link)
#+END_SRC

Above is the definition for my custom =org-make-wiktionary-link= function. Like
the description says, it creates a link to the Wiktionary entry on the selected
word (or, if no region is active, the word where the cursor is). Furthermore, I
have set it to always bring up the Russian definition, but if you copy this
function to your own configuration, you can just set =wiktionary-language= to
='english= or something, or even ='non-existent-language= if you don't want to look
up any specific language.
     
I have written it because I study Russian and write down all the words I
learn in an Org file. For more language-related settings, see the section
on [[#lang][non-English languages]].

*** Tree view
:PROPERTIES:
:CUSTOM_ID: org-tree-view
:END:

Sometimes, I use to write large documents with many headings and many levels.
Sometimes, keeping track of it all requires a substantial amount of brain power.
Wouldn't it be great to have a small outline to the left of the text, where you
could select a section and narrow in on it in a big window to the right?

That's what the following functions are for. They are heavily based on two
answers on the Emacs StackExchange, by [[https://emacs.stackexchange.com/a/9532][Dan]] and [[https://emacs.stackexchange.com/a/14987][blujay]] respectively.

As you can see in my main Org configuration above, I have =org-open-tree-view= set
to a simple keybinding. It opens a clone of the current buffer in a window split
to the left, from which you can browse the structure of the Org file and press
~RET~ or ~<mouse-1>~ to move to a specific heading in the base buffer on the right
and call =org-narrow-to-subtree=. Note that I normally don't need to call
=org-narrow-subtree-from-clone= myself.

I do experience one bug with =org-open-tree-view=, namely that it doesn't
correctly detect when a tree view buffer is already open. It always opens a new
split, which isn't the expected behavior.

I haven't gotten around to debugging the function, but if you can find the
error, please file an issue or send me a pull request on [[https://github.com/jocap/emacs.d/][GitHub]]!

#+NAME: c:org:fun
#+BEGIN_SRC emacs-lisp
(defun org-narrow-subtree-from-clone ()
  "Switch to a cloned buffer's base buffer and narrow in on the
  selected subtree."
  (interactive)
  (let ((buf (buffer-base-buffer)))
    (unless buf
      (error "You need to be in a cloned buffer!"))
    (let ((pos (point))
          (win (car (get-buffer-window-list buf))))
      (if win
          (select-window win)
        (other-window 1)
        (switch-to-buffer buf))
      (widen) ; first widen any potential narrowing
      (goto-char pos)
      (org-narrow-to-subtree) ; narrow to org subtree
      (outline-show-all)))) ; show everything

(defun org-open-tree-view ()
  "Open a clone of the current buffer to the left, resize it to
   30 columns, and bind RET to jump to the same position in
   the base buffer."
  (interactive)
  (let ((tree-view-buffer-name (org-get-tree-view-buffer-name)))
    (if (get-buffer-window tree-view-buffer-name)
        ;; Use existing tree buffer
        (select-window (get-buffer-window tree-view-buffer-name))
      ;; Make new tree buffer
      (split-window-right 30) ; create tree buffer
      (clone-indirect-buffer tree-view-buffer-name nil t)
      (switch-to-buffer tree-view-buffer-name)

      (read-only-mode)
      (widen)                       ; widen if possible
      (outline-show-all)            ; make sure all headings are visible
      (outline-hide-body)           ; hide body
      (setq-local truncate-lines t) ; ensure truncated lines
      (setq-local scroll-margin 0)  ; disable scroll-margin for buffer
      (org-goto-tree-view-top)      ; go to top of tree view

      ;; Do this twice in case the point is in a hidden line
      (dotimes (_ 2 (forward-line 0)))

      ;; Refresh tree view on save
      (add-hook 'after-save-hook #'org-update-tree-view)

      ;; Map keys
      (use-local-map (copy-keymap org-mode-map))
      (local-set-key (kbd "q") ; quit tree view
                     (lambda (&optional &rest args)
                       (interactive)
                       (kill-buffer (current-buffer)) ; kill buffer
                       (delete-window) ; delete window
                       (remove-hook 'after-save-hook #'org-update-tree-view)))
      (local-set-key (kbd "M-<") #'org-goto-tree-view-top)
      (mapc (lambda (key) ; open heading in base buffer
              (local-set-key (kbd key) 'org-narrow-subtree-from-clone))
            '("<mouse-1>" "RET")))))

(defun org-update-tree-view ()
  "Refresh the tree view."
  (let ((buffer                (current-buffer))
        (tree-view-buffer-name (org-get-tree-view-buffer-name)))
    (when (get-buffer-window tree-view-buffer-name)
      (select-window (get-buffer-window tree-view-buffer-name))
      (outline-hide-body) ; refresh tree view
      (beginning-of-line) ; scroll window all the way to the left
      (select-window (get-buffer-window buffer)))))

(defun org-get-tree-view-buffer-name ()
  "Return the the appropriate name for the current file's tree view buffer."
  (if (buffer-base-buffer)
      ;; If buffer is a base buffer
      (error "Not in a base buffer!")
    ;; If buffer is a clone
    (concat "<tree>" (buffer-name))))

(defun org-goto-tree-view-top ()
  "Go to the first heading in the tree view."
  (interactive)
  (push-mark)                   ; add mark
  (goto-char (point-min))       ; go to beginning of buffer
  (org-next-visible-heading 1)  ; go to first heading
  (recenter 0))                 ; put top of window at point

(define-key org-mode-map (kbd "C-c C-t") #'org-open-tree-view)
#+END_SRC

*** Adjusting /org-beginning-of-line/
:PROPERTIES:
:CUSTOM_ID: org-beginning-of-line
:END:

I know the following code will look hectic, but it's quite simple. You only need
to pay attention to a couple of lines. You see, this is the
=org-beginning-of-line= function, copied from the Org source, but modified to use
a function in my Emacs configuration called =smarter-beginning-of-line=, based on
the function with the same name [[http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][written by Bozhidar Batsov]] of Emacs Redux. For
my implementation of it, see the section on [[#c-a][making C-a smarter]]. In a nutshell,
it moves to indentation unless the point is already at indentation, in which
case it moves to the true beginning of line.

Let's have a look at the code and then I'll explain it.

#+NAME: c:org:fun
#+BEGIN_SRC emacs-lisp
(defun org-smarter-beginning-of-line (original-function &optional n)
  "The exact same function as `org-beginning-of-line',
  but with one exception: instead of calling `beginning-of-line'
  twice, it calls `smarter-beginning-of-line' once."
  (interactive "^p")
  (let ((origin (point))
        (special (pcase org-special-ctrl-a/e
                   (`(,C-a . ,_) C-a) (_ org-special-ctrl-a/e)))
        deactivate-mark)
    ;; First move to a visible line.
    (if (bound-and-true-p visual-line-mode)
        (beginning-of-visual-line n)
      (smarter-move-beginning-of-line n))
    (cond
     ;; No special behavior.  Point is already at the beginning of
     ;; a line, logical or visual.
     ((not special))
     ;; `beginning-of-visual-line' left point before logical beginning
     ;; of line: point is at the beginning of a visual line.  Bail
     ;; out.
     ((and (bound-and-true-p visual-line-mode) (not (bolp))))
     ((let ((case-fold-search nil)) (looking-at org-complex-heading-regexp))
      ;; At a headline, special position is before the title, but
      ;; after any TODO keyword or priority cookie.
      (let ((refpos (min (1+ (or (match-end 3) (match-end 2) (match-end 1)))
                         (line-end-position)))
            (bol (point)))
        (if (eq special 'reversed)
            (when (and (= origin bol) (eq last-command this-command))
              (goto-char refpos))
          (when (or (> origin refpos) (= origin bol))
            (goto-char refpos)))))
     ((and (looking-at org-list-full-item-re)
           (memq (org-element-type (save-match-data (org-element-at-point)))
                 '(item plain-list)))
      ;; Set special position at first white space character after
      ;; bullet, and check-box, if any.
      (let ((after-bullet
             (let ((box (match-end 3)))
               (cond ((not box) (match-end 1))
                     ((eq (char-after box) ?\s) (1+ box))
                     (t box)))))
        (if (eq special 'reversed)
            (when (and (= (point) origin) (eq last-command this-command))
              (goto-char after-bullet))
          (when (or (> origin after-bullet) (= (point) origin))
            (goto-char after-bullet)))))
     ;; No special context.  Point is already at beginning of line.
     (t nil))))

(advice-add 'org-beginning-of-line :around #'org-smarter-beginning-of-line)
#+END_SRC

So why all this code?

First of all, Org-mode has its own function for moving to the beginning of the
line, and if you set enable =org-special-ctrl-a/e=, it is really useful. For that
reason, I want to use Org's own function, but force it to use
=smarter-beginning-of-line= instead of =beginning-of-line=.

Now, this /should/ be as easy as just replacing the =beginning-of-line= function
with =smarter-beginning-of-line=, but unfortunately this doesn't work, because
=org-beginning-of-line= stupidly calls =beginning-of-line= /twice/!

This will not work with =smarter-beginning-of-line=, because calling that function
twice will always move the cursor to the actual beginning of line, and never it
will never move to the indentation, which sort of is the point of the entire
function.

The easiest way to solve the problem is, unfortunately, copying the
=org-beginning-of-line= function definition and modifying it to call
=move-beginning-of-line= only /once/. Or in my case, =smarter-beginning-of-line=,
once.

This works well, but of course it will block any potential future changes to
=org-beginning-of-line= by the Org developers. On the other hand, it's unlikely
that such a basic and well-working function should recieve any significant
updates.

** Python mode

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
;; python-mode
(defun shell-compile () ; (courtesy of djangoliv @ stack interchange)
  (interactive)
  (shell-command (concat "python " (buffer-file-name)))
  (if (<= (* 2 (window-height)) (frame-height))
      (enlarge-window 20)
    (/ (frame-height) 2)))
(add-hook 'python-mode-hook
          '(lambda ()
             (define-key python-mode-map (kbd "C-c C-c") 'shell-compile)))
#+END_SRC

** (La)TeX mode

#+NAME: c:basic-prefs
#+BEGIN_SRC emacs-lisp
(add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
(defun my-latex-setup (&optional args)
  (defun start-update-viewer ()
    "Starts/updates PDF viewer."
    (interactive)
    (if (string-match "no process found"
                      (shell-command-to-string "killall -HUP mupdf-x11"))
        (start-process-shell-command
         "mupdf"          ; process name
         "mupdf"          ; process buffer
         (concat "mupdf " ; shell command
                 (expand-file-name
                  (concat "output/"
                          (file-name-base (buffer-file-name))
                          ".pdf"))))))
  (define-key LaTeX-mode-map (kbd "C-c C-u") 'start-update-viewer)

  (defun save-run ()
    "Saves the document and processes it."
    (interactive)
    (save-buffer)
    (TeX-command-run-all nil))

  (defun latex-word-count () ; (courtesy of Nicholas Riley @ SE)
    (interactive)
    (let* ((this-file (buffer-file-name))
           (word-count
            (with-output-to-string
              (with-current-buffer standard-output
                (call-process "texcount" nil t nil "-brief" this-file)))))
      (string-match "\n$" word-count)
      (message (replace-match "" nil nil word-count))))
  (define-key LaTeX-mode-map (kbd "C-c w") 'latex-word-count)

  (defun latex-write-word-count ()
    "Writes the word count to count.txt (if it exists)."
    (interactive)
    (shell-command (concat "texcount -brief "
                    (shell-quote-argument buffer-file-name)
                    " | sed -e 's/+.*//' > count.txt; cat count.txt")))
  (define-key LaTeX-mode-map (kbd "C-c M-w") 'latex-write-word-count))
(add-hook 'LaTeX-mode-hook 'my-latex-setup t)
#+END_SRC


* Custom hooks
:PROPERTIES:
:CUSTOM_ID: custom-hooks
:END:

#+NAME: c:custom-hooks
#+BEGIN_SRC emacs-lisp
;; window-focus-out-hook, window-focus-in-hook

(defun run-window-focus-out-hook (window &optional norecord)
  (run-hooks 'window-focus-out-hook))
(defun run-window-focus-in-hook (window &optional norecord)
  (run-hooks 'window-focus-in-hook))

(advice-add 'select-window :before 'run-window-focus-out-hook)
(advice-add 'select-window :after 'run-window-focus-in-hook)

;; NOTE: This doesn't always play nice with magit. For example, select-window
;; seems to be run when opening the commit message buffer, but *not* when
;; returning to the magit status buffer. I'm not quite sure why, but I suppose I
;; could add an exception for it. I'd have to look at the magit source. Perhaps
;; I could just run a function upon switch-to-buffer that checks whether the
;; current-window is different from the previous-current-window (saved in a
;; variable); that might be the most simple solution, similar to what hl-line
;; does, but as I've said before, more efficient than attaching everything to
;; post-command-hook ...

;; TODO: Add exception for magit buffer switching.

;; before-minibuffer-hook, after-minibuffer-hook

(defun run-before-minibuffer-hook (&optional &rest args)
  (run-hooks 'before-minibuffer-hook)
  (add-hook 'post-command-hook 'run-after-minibuffer-hook))
(defun run-after-minibuffer-hook (&optional &rest args)
  (unless (minibufferp)
    (run-hooks 'after-minibuffer-hook)
    (remove-hook 'post-command-hook 'run-after-minibuffer-hook)))

(advice-add 'read-from-minibuffer :before 'run-before-minibuffer-hook)
(advice-add 'read-no-blanks-input :before 'run-before-minibuffer-hook)
(advice-add 'read-string          :before 'run-before-minibuffer-hook)

;; before-helm-hook, after-helm-hook

(defun run-before-helm-hook (&optional &rest args)
  (run-hooks 'before-helm-hook))
(defun run-after-helm-hook (&optional &rest args)
  (run-hooks 'after-helm-hook))

(add-hook 'helm-before-initialize-hook 'run-before-helm-hook)
(add-hook 'helm-exit-minibuffer-hook   'run-after-helm-hook)
(advice-add 'helm-keyboard-quit :after 'run-after-helm-hook)
#+END_SRC


* Themes
:PROPERTIES:
:CUSTOM_ID: themes
:END:

** Theme configuration

I like to be flexible when it comes to themes. For example, I want to be able to
switch themes in the middle of a session without any issues. I also want Emacs
to automatically load a sensible theme depending on the amount of daylight.
Furthermore, I want to be able to easily adjust the themes I use, because they
aren't perfect.

I believe I have succeeded in achieving my goals, and rather nicely at that.

*** Daylight-dependent default theme
:PROPERTIES:
:CUSTOM_ID: daylight-sets-color
:END:

This is a function that I have ported from my old =vimrc=. It relies on =sun=, a
highly personalized script of which I am /not/ particularly proud, because of how
ugly it is ... But if you absolutely /have/ to see it, it's available at [[https://github.com/jocap/uppsala-sun][GitHub]] -
you've been warned.

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(defun daylight-sets-color ()
  "Sets a light theme for day and a dark theme for night.
  Depends on the script `sun' being found in path."
  (interactive)
  (let ((time (string-to-number (format-time-string "%H.%M"))))
        (if (string-match "not found" (shell-command-to-string "which sun"))
            (if (and (> time 6.00) (< time 18.00)) ; default if `sun' not found
                (load-theme light-theme t)
              (load-theme dark-theme t))
          (let ((sunrise
                 (string-to-number (shell-command-to-string "sun _rise")))
                (sunset
                 (string-to-number (shell-command-to-string "sun _set"))))
            (if (and (> time sunrise) (< time sunset))
                (load-theme light-theme t)
              (load-theme dark-theme t))))))
#+END_SRC

The function depends on the following variables being set:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(setq light-theme 'eziam-light
      dark-theme  'eziam-dark)
#+END_SRC

To set the default theme on startup, I use the following code:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'daylight-sets-color)
#+END_SRC

*** Dynamic theme settings
:PROPERTIES:
:CUSTOM_ID: dynamic-theme-settings
:END:

Another of my goals was being able to easily adjust the colors of individual
themes. While my solution may not be "simple", it is efficient and easy to use.

The way I have it set up is that every time a theme is loaded, a function called
=theme-do-all= is run:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(advice-add 'load-theme :after (lambda (theme &optional rest ...)
                                 (theme-do-all theme)))
#+END_SRC

The =theme-do-all= function contains a bunch of different settings: some for all
themes, some only for specific themes.

The more interesting aspect of the function, however, is the way it sets up
/dynamic colors/, dependent on the colors of the loaded theme. For example, I
don't set a custom =fci-rule-color= (that's /fill-column-indicator/) for every
theme. Instead, I base it on the background color of the loaded theme, making it
stick out just enough to be distinguishable. This way, I can load /any/ theme and
the =fci-rule-color= will automatically be set to a sensible color.

To achieve this, I use the =color= functions. I also define my own =intensify= and
=anti-intensify= functions, which depend on the lightness of the theme's
background.

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
(defun theme-do-all (theme)
  "Actions to perform whenever a theme is loaded."

  (require 'color) ; for color-* functions

  (let* ((bg
          (alist-get 'background-mode (frame-parameters)))
         (intensify
          (if (eq bg 'dark) 'color-darken-name 'color-lighten-name))
         (anti-intensify
          (if (eq bg 'dark) 'color-lighten-name 'color-darken-name)))

    ;; Settings for all themes
    ;; ***********************

    ;; * Dynamic mouse pointer color
    (set-mouse-color
     (if (eq bg 'dark) "#ffffff" "#000000"))

    ;; * fci-rule-color -> desaturate, anti-intensity
    (setq fci-rule-color (color-desaturate-name
                          (funcall anti-intensify
                                   (face-attribute 'default :background) 15) 50))

    ;; * org-block-background -> desaturate, darken
    (set-face-attribute 'org-block nil
                        :background (color-desaturate-name
                                     (color-darken-name
                                      (face-attribute 'default :background) 3) 20)
                        :foreground (face-attribute 'default :foreground))

    ;; * org-block-begin-line, org-block-end-line
    (cl-loop
     for face in '(org-block-begin-line org-block-end-line)
     do (set-face-attribute
         face nil
         :background (color-desaturate-name
                      (color-darken-name
                       (face-attribute 'default :background) 15) 50)
         :foreground (color-desaturate-name
                      (funcall intensify
                               (face-attribute 'default :foreground) 20) 90)
         :weight (face-attribute 'default :weight)
         :slant (face-attribute 'default :slant)))

    ;; * Reset fci-mode
    (let ((inhibit-message t))
      (call-interactively 'fci-mode)
      (call-interactively 'fci-mode))

    ;; Settings for specific themes
    ;; ****************************

    (cl-case theme
      ;; * Gruxbox
      ('gruvbox
       (custom-theme-set-faces
        'gruvbox ; fix hard-to-see org-mode colors
        '(org-verbatim ((t (:foreground "DarkGray"))))
        '(org-document-info-keyword ((t (:foreground "DarkGoldenrod"))))))

      ;; * Tango
      ('tango
       (custom-theme-set-faces
        'tango
        '(hl-line ((t (:background "#dddddd"))))))

      ;; * Tango-dark
      ('tango-dark
       (custom-theme-set-faces
        'tango-dark ; fix crazy hl-line (bright yellow per default!)
        '(hl-line ((t (:background "#444444")))))))

    ;; * Eziam
    (when (or (equal theme 'eziam-dark) (equal theme 'eziam-light))
      (custom-theme-set-faces
       theme
       ;; - Less contrastive cursor
       `(cursor ((t (:background
                     ,(funcall
                       anti-intensify
                       (face-attribute 'default :foreground) 25)))))
       ;; - More contrastive paren match
       `(show-paren-match ((t (:background
                               ,(funcall
                                 anti-intensify
                                 (face-attribute 'default :background) 25))))))
      ;; - Fading rainbow-delimiters (from black to light gray)
      (cl-loop for n in (number-sequence 1 9)
               do (let ((face-name (concat
                                    "rainbow-delimiters-depth-"
                                    (number-to-string n)
                                    "-face"))
                        (color (funcall
                                intensify
                                (face-attribute 'default :foreground)
                                (* n 6))))
                    (custom-theme-set-faces
                     theme
                     (list (intern face-name) `((t (:foreground ,color))))))))))
#+END_SRC

It may look a bit busy, but that's because of the nature of setting face
attributes via Emacs Lisp.

Among some of the interesting settings are the custom =rainbow-delimiters= fading
from black to light gray - or from white to dark gray, if =eziam-dark= is loaded
instead of =eziam-light=.

*** Switching between themes
:PROPERTIES:
:CUSTOM_ID: theme-switching
:END:

To switch themes, I simply use =load-theme=. There is one problem with that,
though. Per default, =load-theme= doesn't unload the old theme. The following
code, surely copied from the internet, fixes that:

#+NAME: c:theme:config
#+BEGIN_SRC emacs-lisp
;; - Disable previous theme when enabling new theme
(add-hook 'after-init-hook
          (lambda () (defadvice load-theme
                         (before theme-dont-propagate activate)
                       (mapcar #'disable-theme custom-enabled-themes))))
#+END_SRC


* Language configuration
:PROPERTIES:
:CUSTOM_ID: lang
:END:

** TODO Spelling
:PROPERTIES:
:CUSTOM_ID: spelling
:END:

# add NAME when done
#+BEGIN_SRC emacs-lisp
(require 'ispell)
(add-to-list 'ispell-dictionary-alist
             '("swedish-hunspell"
               "[[:alpha:]]"
               "[^[:alpha:]]"
               "[']"
               t
               ("-d" "sv_SE")
               nil
               utf-8))

(add-to-list 'ispell-dictionary-alist
             '("english-hunspell"
               "[[:alpha:]]"
               "[^[:alpha:]]"
               "[']"
               t
               ("-d" "en_US")
               nil
               utf-8))
(setq ispell-program-name "hunspell"
      ispell-dictionary   "swedish-hunspell")
#+END_SRC

** Swedish mode
:PROPERTIES:
:CUSTOM_ID: swe
:END:

#+NAME: c:lang:config
#+BEGIN_SRC emacs-lisp
;; Based on work by Moritz Ulrich <ulrich.moritz@googlemail.com>
;; Published under GNU General Public License

(defvar swedish-mode-map (make-keymap) "Swedish mode keymap.")

(define-key swedish-mode-map (kbd "s-[")  (lambda () (interactive) (insert ?√•)))
(define-key swedish-mode-map (kbd "s-'")  (lambda () (interactive) (insert ?√§)))
(define-key swedish-mode-map (kbd "s-;")  (lambda () (interactive) (insert ?√∂)))
(define-key swedish-mode-map (kbd "s-{")  (lambda () (interactive) (insert ?√Ö)))
(define-key swedish-mode-map (kbd "s-\"") (lambda () (interactive) (insert ?√Ñ)))
(define-key swedish-mode-map (kbd "s-:")  (lambda () (interactive) (insert ?√ñ)))

(define-minor-mode swedish-mode
  "A mode for conveniently using Swedish letters in Emacs."
  nil
  :lighter " √•√§√∂"
  swedish-mode-map)

(provide 'swedish-mode)
#+END_SRC

** Combining acute accent
:PROPERTIES:
:CUSTOM_ID: combining-acute-accent
:END:

#+NAME: c:lang:config
#+BEGIN_SRC emacs-lisp
;; Insert combining acute accent
(global-set-key (kbd "C-c 8 '") (lambda () (interactive) (insert-char 769)))
#+END_SRC


* Preventing repeated strain injury
:PROPERTIES:
:CUSTOM_ID: rsi
:END:


* Non-Emacs Emacs-related configuration

** Windows Subsystem for Linux (WSL)
:PROPERTIES:
:CUSTOM_ID: wsl
:END:

I only own Windows PCs, with Windows installed on every single one, and I do
rely on Windows for a lot of things: PC games, Microsoft Word, the experience of
using a commercial and well-functioning operating system ... My only problem is
programming. I /cannot/ program on Windows. =cmd.exe=, as well as the newer
PowerShell, is unusable - not necessarily because they suck, but because I'm
very used to *nix systems.

/Bash on Ubuntu on Windows: Windows Subsystem for Linux/ (WSL for short) solves
that problem for me. It isn't perfect and everything doesn't work great. But
most things work really well - surprisingly well, even. I am as amazed as
impressed by the work done by the WSL team. My respect for Microsoft, as well as
the Windows' potential as a powerful development environment, is higher than
ever.

Using WSL does mean I have to do some things a bit differently, and adjust my
configuration accordingly. Most of this configuration happens in my Zsh
configuration files, but some of it inevitably leaks into my Emacs
configuration.

*** Default programs
:PROPERTIES:
:CUSTOM_ID: wsl:default
:END:

I use WSL for most development tools - like Emacs, Zsh and the odd local web
server - but I use native Windows programs for things like music playing and
web browsing.

**** Web browser
:PROPERTIES:
:CUSTOM_ID: wsl:web-browser
:END:

***** Problem

My web browser of choice is Firefox, because of the extensibility and
reliability. Emacs can be configured to use Firefox by customizing
=browse-url-browser-function= and setting it to /Firefox/. This will make
Emacs attempt to launch Firefox when I click on a link.

Of course, I haven't got Firefox installed on my WSL system, but I symlinked
=~/bin/firefox= to the path of the Windows version of Firefox:

#+BEGIN_SRC sh :tangle no
ln -s /mnt/c/Program\ Files/Mozilla\ Firefox/firefox.exe ~/bin/firefox
#+END_SRC

For a while, this solution worked fine. However, not all modes respect the
=browse-url-browser-function= setting. org-mode tries to use
=sensible-browser=, which relies on the =BROWSER= variable. To make
=sensible-browser= use Firefox, I simply put the following in my Zsh
configuration:

#+BEGIN_SRC sh :tangle no
export BROWSER="firefox"
#+END_SRC

Still, when org-mode tries to open the HTML file it just exported, it seems
to run into some problem. A Firefox window opens, but it's empty, without
any URL in the address bar!

This happens when Emacs tries to open /any/ file in the web browser, simply
because =firefox.exe= won't recognize any Linux path. It needs a /Windows/
path.

***** Solution

To solve this once and for all, I scrapped my old symlinks and aliases and
instead, wrote the following shell script:

#+BEGIN_SRC sh :tangle ~/bin/wsl-browser
#!/usr/bin/zsh

if [[ $1 =~ ^https?:// ]]; then
    local open_path="$1"
elif [[ $1 =~ ^/mnt/c ]]; then
    local linux_path="/mnt/c"
    local windows_path="file:///C:/"
    local open_path="${1/$linux_path/$windows_path}"
else
    local abs_path=$(readlink -f $1)
    local open_path="file:///C:/Users/JohnAJ/AppData/Local/lxss$abs_path"
fi

/mnt/c/Program\ Files/Mozilla\ Firefox/firefox.exe $open_path
#+END_SRC

The script treats any argument starting with =http://= or =https://= as normal URLs.
Any other path, it tries to convert to the equivalent Windows path.

At first, I didn't have the /elif/-clause, but I noticed that sometimes, Emacs
would try to open in the web browser a file that was on the Windows-side of the
filesystem - that is, with a path starting with =/mnt/c=.

Within the Linux system, =/mnt/c= is an access point to all files on the Windows
installation. Within the Windows system, =C:\Users\JohnAJ\AppData\Local\lxss= is
an access point to the Linux file system. But despite that,
=C:\Users\JohnAJ\AppData\Local\lxss\mnt\c= does /not/ resolve to =C:\=.

For this reason, I couldn't just tell =firefox.exe= to open
=file:///C:/Users/JohnAJ/AppData/Local/lxss/mnt/c/=. To Windows programs, it's an
empty directory. I therefore added a special case for all paths starting with
=/mnt/c=, redirecting straight to =file:///C:/=, which isn't an empty directory.

I saved the script as =~/bin/wsl-browser=, the =~/bin= directory being in my =$PATH=,
and gave myself permissions to run it:

#+BEGIN_SRC sh :tangle no
chmod +x ~/bin/wsl-browser
#+END_SRC

Additionally, I symlinked both =firefox= and =sensible-browser=
to the file. This way, any tool on my system that tries to use one of those
programs will use my script instead.

In Emacs, my default browser is =firefox=, so that it remains compatible
with other systems, where I don't use my =wsl-browser= script.


* Credits


#+NAME: c:config-all
#+BEGIN_SRC emacs-lisp :noweb yes :tangle "config.el" :exports none
;; First & foremost
;; =============================================================================

<<c:first-and-foremost>>

;; Packages
;; =============================================================================

<<c:pkg:management>>
<<c:pkg:config>>

;; Basic preferences
;; =============================================================================

<<c:basic-prefs>>

;; Keybindings
;; =============================================================================

<<c:keybindings>>

;; Themes
;; =============================================================================

<<c:theme:config>>

;; Language configuration
;; =============================================================================

<<c:lang:config>>

;; Custom hooks
;; =============================================================================

<<c:custom-hooks>>

;; Lastly
;; =============================================================================

(load custom-file)
#+END_SRC
